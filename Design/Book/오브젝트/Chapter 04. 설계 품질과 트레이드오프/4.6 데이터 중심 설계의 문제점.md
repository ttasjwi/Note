# <a href = "../README.md" target="_blank">오브젝트</a>
## Chapter 04. 설계 품질과 트레이드오프
### 4.6 데이터 중심 설계의 문제점
1) 객체의 행동보다는 상태에 초점을 맞춘다.
2) 객체를 고립시킨 채 오프레이션을 정의하도록 만든다.

---

# 4.6 데이터 중심 설계의 문제점

데이터 중심 설계가 변경에 취약한 이유는 다음과 같다.
- 객체의 행동보다는 상태에 초점을 맞춤으로서, 너무 일찍부터 데이터에 관해 결정하도록 강요함
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정

---

## 1) 객체의 행동보다는 상태에 초점을 맞춘다.

### 1.1 첫번째 설계의 문제점
- 데이터와 기능을 분리하는 전형적인 절차적 프로그래밍
- 데이터는 단순한 데이터의 집합체. 객체를 사용하는 절차를 별도의 객체 안에 구현하게 됨
- 접근자, 수정자는 객체의 상태를 public으로 열어둔 것과 차이가 없으므로 객체의 캡슐화가 무너질 수 밖에 없음

### 1.2 두번째 설계의 문제점
- 데이터와 기능을 일단 같은 객체에 두긴 했으나, 결국 근본적인 설계부터가 데이터에 맞춰져 있음
- 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하므로, 데이터에 관한 방대한 지식이
객체의 인터페이스에 고스란히 드러나게 됨(calculateAmountDiscountFee, calculatePercentDiscountFee, ...)
- 객체의 인터페이스가 구현을 캡슐화하는데 실패하여, 코드는 변경에 취약해짐

### 1.3 결론
- 데이터 중심의 설계는 너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패함
- 객체 내부 구현이 객체의 인터페이스를 어지럽히고, 객체의 응집도와 결합도에 나쁜 영향을 끼치기에 변경에 취약한 코드를 낳게 됨

---

## 2) 객체를 고립시킨 채 오프레이션을 정의하도록 만든다.

### 2.1 초점이 객체 외부가 아니라 내부로 향하게 됨
- 실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정함
- 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기에,
이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없게 됨.

### 2.2 두번째 설계 : 객체 간 협력이 구현 세부사항에 종속
- 협력의 맥락에 대한 고민 없이 단순히 데이터와 기능을 한 곳에 두었고, 객체의 인터페이스에 구현이 노출됨
- 결과적으로 억지로 만든 협력이 구현 세부사항에 종속되어 있었고, 그에 따라 객체 내부의 구현이 변했을 때
협력하는 객체 모두가 영향을 받을 수밖에 없었다.

---
