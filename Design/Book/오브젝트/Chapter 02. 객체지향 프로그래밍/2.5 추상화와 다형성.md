# <a href = "../README.md" target="_blank">오브젝트</a>
## Chapter 02. 객체지향 프로그래밍
### 2.5 추상화와 다형성
1) 추상화의 장점 1: 도메인의 주요 개념, 정책을 높은 수준에서 간단하게 표현할 수 있다.
2) 추상화의 장점 2: 유연한 설계
3) 추상 클래스와 트레이드 오프
4) 코드를 재사용하는 두 가지 방법 : 상속, 합성
5) 상속을 통한 코드 재사용
6) 합성을 통한 코드 재사용

---

# 2.5 추상화와 다형성

---

## 1) 추상화의 장점 1: 도메인의 주요 개념, 정책을 높은 수준에서 간단하게 표현할 수 있다.

- 추상화를 이용하면, 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
- 세부 사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있다.
- 필요에 따라 표현의 수준을 조정하는 것을 가능하게 한다.
- 추상화를 이용해 상위 정책을 기술하는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.
- 자식 클래스들은 추상화를 이용해 정의한 상위의 협력 흐름을 그대로 따르게 된다.
- 재사용 가능한 설계의 기본을 이루는 디자인 패턴, 프레임워크 역시 추상화를 이용해 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고 있다.

---

## 2) 추상화의 장점 2: 유연한 설계
- 기존 구조를 수정하지 않고 새로운 기능을 쉽게 추가, 확장하여 설계를 유연하게 할 수 있다.
    - 할인 정책이 없는 경우에만 조건문을 통해 분기처리할 경우 할인 금액을 결정하는 책임이 Movie에게 이동하게 됨.
      결국 기존의 일관성 있는 협력 방식이 무너짐.
        - 책임의 위치를 결정하기 위해 조건문을 사용하여 특수한 경우에만 분기처리하는 것은 협력의 설계 측면에서 좋지 않은 선택이 됨.
        - 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하자.
- NoneDiscountPolicy를 구현하여 일관성을 유지할 수 있음. 기존의 코드를 수정하지 않고, 새로운 클래스를 추가하는 것만으로 애플리케이션의 기능을
  확장한 것이다.
- 추상화를 통해, 설계가 구체적인 상황에 결합되는 것을 방지하고 유연한 설계를 가능하게 한다.
- 특정 구현체에 의존하지 않고 추상적인 대상을 의존한 덕분에 유연한 설계가 가능해졌는데 이런 개념은 8장의 '컨텍스트 독립성'에서 다룰 것
    - 이 개념은 프레임워크와 같은 유연한 설계가 필수적인 분야에서 진가를 발휘한다.

---

## 3) 추상 클래스와 트레이드 오프
- NoneDiscountPolicy의 `getDiscountAmount()` 메서드가 어떤 값을 반환하더라도 관계가 없다. 상위 클래스인 DiscountPolicy의
  `calculateDiscountAmount()`로 인해 결국 0원이 할인된다.
- NoneDiscountPolicy는 상속으로 인해 상위 추상 클래스인 DiscountPolicy와 강하게 개념적으로 결합되는 문제가 발생했다.
- 이런 문제를 해결하기 위해 DiscountPolicy를 인터페이스로 하고, 하위에 DefaultDiscountPolicy, NoneDiscountPolicy를 두었다.
- NoneDiscountPolicy- DiscountPolicy의 강결합 문제되어 좀 더 설계가 유연해졌으나, 전반적인 복잡도가 증가하였다. 이것은 결국 트레이드 오프다.
- 우리가 작성하는 모든 코드에는 합당한 이유가 있어야하며, 사소한 결정이더라도 트레이드 오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의
  차이는 매우 크다. 고민하고 트레이드 오프를 하자.

---

## 4) 코드를 재사용하는 두 가지 방법 : 상속, 합성
- 코드를 재사용하는 방법으로는 크게 두가지, 상속과 합성이 있다.
- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
- Movie가 DiscountPolicy를 인스턴스 변수로 하여 DiscountPolicy의 코드를 재사용하는 방법이 바로 합성이다.
- 사람들이 상속 대신 합성을 더 선호하는 이유는? (아래에서 서술)

---

## 5) 상속을 통한 코드 재사용
- 상속은 두 가지 관점에서 설계에 악영향을 끼친다.
    - 캡슐화 위반
    - 설계를 유연하지 못 하게 한다.
- 캡슐화 위반
    - 상속을 사용하기 위해서는, 부모의 내부 구조를 잘 알고 있어야한다.
    - 하위 클래스 개발자는 부모 클래스의 맥락을 알고 있어야한다.
    - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    - 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에, 부모 클래스가 변경될 때 자식 클래스도 함께 변경될 확률을 높인다.
    - 상속을 과도하게 사용한 코드는 변경하기 더 어려워진다.
- 설계를 유연하지 못 하게 함
    - 부모-자식 클래스 관계가 컴파일 시점에 결정됨으로 인해 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
    - 런타임에 객체의 종류를 변경하려면, 다른 인스턴스를 생성하고 프로퍼티를 복사해서 생성해야함.
    - 이 역시 부모-자식 클래스가 강하게 결합되어 있기 때문에 발생함
- 상속의 예 : Movie -> (상속) AmountDiscountMovie, PercentDiscountMovie
    - 런타임의 Movie 인스턴스의 타입을 변경하기 매우 힘들어짐
    - 상속보다 인스턴스 변수로 관계를 연결하면 원래 설계가 더 유연해짐 (changeDiscountPolicy)

---

## 6) 합성을 통한 코드 재사용
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용함
- 인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에, 구현을 효과적으로 캡슐화
- 의존하는 인터페이스를 교체하는 것이 쉽기 때문에 설계를 유연하게 함.
- 상속은 상위 클래스와 강하게 결합되는 데에 비해, 합성은 메시지를 통해 느슨하게 결합됨.
- 따라서 코드의 재사용을 목적으로 한다면 상속을 사용하기 보다 합성을 선호하는 것이 더 좋다.
- 하지만 모든 상황에서 합성만을 사용해야하는 것은 아니다. 상황에 맞게 적절하게 합성과 상속을 함께 사용해야한다.
    - 이전의 DefaultDiscountPolicy의 사례와 같이 다형성을 위해 인터페이스를 재사용을 하는 경우에는 합성, 상속을 함께 사용해야함.

---
