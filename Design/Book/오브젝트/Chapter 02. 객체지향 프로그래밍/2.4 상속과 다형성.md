# <a href = "../README.md" target="_blank">오브젝트</a>
## Chapter 02. 객체지향 프로그래밍
### 2.4 상속과 다형성
1) 컴파일 시간 의존성과 런타임 의존성
2) 상속 : 코드의 재사용, 차이에 의한 프로그래밍
3) 상속과 인터페이스 : 부모 클래스를 자식 클래스로 대체 가능
4) 다형성 : 동일한 메시지를 수신했을 때, 객체의 타입에 따라 각각 다르게 응답할 수 있는 능력
5) 순수 인터페이스 상속을 통한 다형성 구현 : java에서의 '인터페이스'

---

# 2.4 상속과 다형성

Movie 클래스 어디에서도 할인 정책이 금액 할인 정책인지, 비율 할인 정책인지 판단하지 않는다.  
단지 Movie에서 할인 정책에 메시지를 보낼 뿐인데, 이를 통해 어떻게 영화 최종 요금을 계산할 수 있었던 것일까?  
이 질문에 대답하기 위해서는 '상속', '다형성'의 개념을 확인해봐야 한다.  

---

## 1) 컴파일 시간 의존성과 런타임 의존성

### 1.1 컴파일 시간 의존성, 런타임 의존성
- 컴파일 시간 의존성(클래스 의존성) : 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나, 해당 클래스의 객체의 메서드를 호출할 경우
두 클래스 사이에 의존성이 존재한다고 말한다.
- 런타임 인스턴스 의존성 : 실제 실행시 Movie 인스턴스는 DiscountPolicy가 아닌 PercentDiscountPolicy 또는 AmountDiscountPolicy를
의존하고 있다.

### 1.2 컴파일 시간 의존성, 런타임 의존성은 동일하지 않을 수 있다.
- 클래스 사이의 의존성과 실제 런타임 객체 사이의 의존성은 동일하지 않을 수 있다.
- 코드의 의존성과 실행 시간 의존성이 다르면 다를 수록 코드는 더 유연하고 확장 가능해진다.
- 코드의 의존성과 실행 시간 의존성이 다르면 다를 수록 코드를 이해하기 어렵다.
  - 코드를 이해하기 위해, 코드뿐 아니라 객체를 생성하고 연결하는 부분을 찾아야하기 때문이다.

### 1.3 결국 설계는 트레이드 오프
- 코드의 의존성의 양면성을 통해 설계가 트레이드 오프의 산물임을 확인할 수 있다.
  - 설계가 유연해질 수록 코드를 이해하고, 디버깅하기는 더 어려워진다. 반변 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만
  재사용성과 확장 가능성은 낮아진다.
- 무조건 유연한 설계도 무조건 읽기 쉬운 코드도 정답은 아니다. 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서
  고민해야한다.

---

## 2) 상속 : 코드의 재사용, 차이에 의한 프로그래밍

### 2.1 상속(inhreitance)
- 상속은 두 클래스의 관계를 정의하는 방법
- 상속 관계 선언을 통해 한 클래스는 자동으로 다른 클래스가 제공하는 코드를 자신의 일부로 합 칠 수 있다.
- 상속을 통해 코드 중복을 제거하고 여러 클래스 사이에서 동일한 코드를 재사용할 수 있다.
- 상속 관계의 객체를 나타내는 여러가지 용어들
    - 코드를 제공하는 클래스 : 슈퍼 클래스, 부모 클래스, 직계 조상, 기반 클래스...
    - 코드를 제공받는 클래스 : 서브 클래스, 자식 클래스, 직계 자손, 파생 클래스...
- 클래스 관계는 상대적이며 어느 클래스를 기준으로 하느냐에 따라 상속 관계에 참여하는 클래스의 역할이 달라진다.

### 2.2 코드 재사용과 상속
- 상속을 통해 클래스의 코드를 전혀 수정하지 않고, 하위 클래스에서 재사용하게 할 수 있다.
- 상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.
- 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
- 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공한다.

### 2.3 차이에 의한 프로그래밍
- 상속을 이용하면, 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 '차이에 의한 프로그래밍'이라고 부른다.

---

## 3) 상속과 인터페이스 : 부모 클래스를 자식 클래스로 대체 가능

### 3.1 퍼블릭 인터페이스를 자식이 물려받음
- 상속이 가치 있는 이유는 부모 클래스가 외부에 제공하는 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
- 상속을 통해 자식 클래스는 부모 클래스의 인터페이스를 포함하게 된다.

### 3.2 자식 클래스로의 대체 가능성
- 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에
클라이언트는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
- 클라이언트는 협력 객체가 자신이 송신하는 메시지를 이해할 수 있다면 그 객체가 어떤 클래스의 인스턴스인지 상관하지 않는다.
- 결국 자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에, 부모 클래스 대신 사용될 수 있다.
- 실제로 객체 지향 프로그래밍 언어의 컴파일러들은 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
- 참고) 업캐스팅(upcasting) : 자식 클래스가 부모 클래스를 대신하는 것

---

## 4) 다형성 : 동일한 메시지를 수신했을 때, 객체의 타입에 따라 각각 다르게 응답할 수 있는 능력

### 4.1 다형성
- 다형성 : 동일한 메시지를 수신했을 때, 객체의 타입에 따라 각각 다르게 응답할 수 있는 능력
    - 클라이언트는 동일한 메시지를 전송하지만, 수신 받는 객체가 이를 처리하는 메서드는 객체 자신의 클래스가 무엇인가에 따라 달라진다.
- 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체 지향의 특성을 이용해, 서로 다른 메서드를 실행할 수 있게 한다.
- 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야한다. 즉, 인터페이스가 동일해야한다.

### 4.2 지연 바인딩, 동적 바인딩
- 메시지에 응답하기 위해 실행할 메서드를 컴파일 시점이 아닌 실행 시점에 바인딩하는 특징
  - 참고) 초기 바인딩, 정적 바인딩 : 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것
- 지연바인딩을 통해, 컴파일 의존성과 실행타임 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있다.

### 4.3 다형성과 상속
- 다형성을 구현하는 방법은 다양하다. 상속은 다형성을 구현하는 방법 중 하나에 불과하다.
- 상속을 통해, 동일한 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다.

### 4.4 (참고) 구현 상속과 인터페이스 상속
- 구현 상속, 서브클래싱 : 순수하게 코드를 재사용하기 위한 상속
- 인터페이스 상속, 서브타이핑 : 다형적인 협력을 통해 부모, 자식 클래스가 인터페이스를 공유하는 것
- 상속은 구현 상속이 아닌 인터페이스 상속을 위해 사용해야한다. 인터페이스를 재사용할 목적이 아니라, 구현을 재사용할 목적으로
상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.

---

## 5) 순수 인터페이스 상속을 통한 다형성 구현 : java에서의 '인터페이스'
- 구현 상속이 아닌, 순수하게 인터페이스만 공유하고 싶을 때가 있는데 이를 위해 java, C# 등에서는 '인터페이스'라는 프로그래밍 요소를 제공함
- 예제 코드에서, 추상클래스를 통해 다형성을 구현했던 할인 정책과 다르게, 할인 조건은 자바의 인터페이스를 이용해 타입 계층을 구현했다.
- 순번 할인 조건, 기간 할인 조건은 동일한 '할인조건' 인터페이스를 공유하며 '할인조건'으로서 업캐스팅하여 다형적인 협력에 참여할 수 있었다.

---
