# 오브젝트

- 조영호 님의 서적 [오브젝트](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=193681076) 정리

---

# Chapter 01. 객체, 설계

- 이론보다 실무가 먼저 : 프로그래밍을 통해 개념과 이론을 배우는 것이 더 훌륭한 학습 방법

## 1.1 티켓 판매 애플리케이션 구현하기
- Theater가 audience의 bag, ticketSeller의 TicketOffice를 알고 있음
- 애플리케이션 로직이 Theater에 집중되어있음

## 1.2 무엇이 문제인가
> 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야한다.

- 제대로 실행은 되지만, 변경이 쉽지 않고, 이해하기 어렵다.
- 읽기 어려운 코드, 예상을 벗어나는 코드
  - Audience, TicketSeller가 Theater의 통제를 받는 수동적인 존재
  - 코드의 맥락을 읽어보면 우리의 상식과 너무 다르게 동작하기 때문에 코드를 읽는 다른 사람과 제대로 의사소통하기 어렵다.
  - 하나의 클래스, 메서드에서 너무 많은 세부사항을 다루기 때문에 코드 작성자 뿐 아니라 코드를 이해해야하는 사람 모두에게 큰 부담을 줌
- 변경에 취약한 코드
  - 다른 클래스가 Audience의 내부에 대해 더 많이 알면 알 수록 Audience를 더 변경하기 어려워짐
  - 의존성 -> 변경에 대한 암시 -> 어떤 객체가 변경될 때 이를 의존하는 다른 객체도 함께 변경될 수 있다 
    - 결합도(coupling) : 객체 사이의 의존성이 과하다 = 결합도가 높다.
  - 그러나 의존성을 완전히 없애는 것이 정답은 아니다. 결국 만들고자 하는 것은 협력하는 객체들의 공동체를 구축하는 것.
  현실적인 목표로, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것을 두자
  - 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것을 목표로 두자.

## 1.3 설계 개선하기
- 문제점
  - 어떤 객체가 자기 자신의 일을 스스로 처리하지 못 하는 것은 우리의 직관을 벗어난다.
    - 우리의 의도를 정확하게 의사소통하지 못 하기 때문에 이해하기 어려운 코드가 됐다.
  - 불필요한 의존성이 발생하여 결합도가 높아지고, 변경의 파급효과가 커짐으로서 변경하기 어려운 코드가 됨
- 자율성을 높이자
  - 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임짐으로서 객체를 자율적인 존재로 만듬
  - 캡슐화(encapsulation) : 개념적으로, 물리적으로 객체 내부의 세부적인 사항을 감추는 것
    - 캡슐화의 목표는 변경하기 쉬운 객체를 만드는 것
    - 객체 내부의 세세한 부분까지 알지 못 하도록 정보에 대한 접근을 제한함으로서, 객체간 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게
    변경할 수 있게 됨
  - 객체를 인터페이스(interface)와 구현(implemenation)으로 나누고 인터페이스만을 공개하는 것은 객체 간의 결합도를 낮추고
  변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙
- 무엇이 개선됐는가
  - TicketSeller, Audience는 자신의 데이터를 스스로 관리함
    - 우리의 예상과 정확히 일치함 -> 코드를 읽는 사람과의 의사소통 관점에서 개선됨
    - Audience, TicketSeller 내부 구현을 변경하더라도 Theater를 변경할 필요가 없어짐
- 어떻게 한 것인가
  - 불필요한 내부 구현을 은닉하고, 객체 스스로 자기 자신의 문제를 스스로 해결하도록 코드로 변경
  - 덕분에 이해하기 쉽고, 변경에 유연한 설계를 얻을 수 있었다.
- 캡슐화, 응집도
  - 핵심 : 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것
  - 응집도(cohension) : 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에에 위임하는 객체는 응집도가 높다.
  - 자율적인 객체를 만들면 결합도를 낮출 수 있고, 응집도를 높일 수 있다.
  - 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임지고 처리할 수 있는 자율적인 존재로 만드는 것.
  - 외부의 간섭을 최대한 배제하고, 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를
  얻을 수 있는 지름길
- 절차지향과 객체지향
  - 절차적 프로그래밍(Procedural Programming) : 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
    - 우리의 직관에 위배됨
    - 코드를 읽는 사람과 원활하게 의사소통하지 못함
    - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.
    - 변경하기 어려운 코드를 양산하는 경향이 있음
  - 객체지향 프로그래밍(Object-Oriented Prgramming) : 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
    - 훌륭한 객체지향 설계의 핵심 : 캡슐화를 통해 의존성을 적절히 관리함으로서 객체 사이의 결합도를 낮추는 것
- 책임의 이동
  - 책임의 집중 : 책임이 한 곳에 집중됨 -> 일반적인 절차적 프로그래밍 방식
    - 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있을 경우 절차적 프로그래밍 방식을 따르고 있을 확률이 크다. 
  - 책임의 이동, 분산 : 각 객체에 적절한 책임이 분배 -> 각 객체는 객체 자신을 스스로 책임짐
    - 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 분산하여 할당하는 것
    - 객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당하느냐에 초점을 맞춰야한다
  - 불필요한 의존성을 제거하고, 결합도를 낮춰라.
    - 설계를 어렵게 만드는 것은 불필요한 의존성.
    - 불필요한 세부사항을 캡슐화하는 **자율적인 객체들**(책임의 분산)이 낮은 결합도와 높은 응집도를 가지고 협력하도록,
    최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계 
- 더 개선할 수 있다
  - Bag을 자율적인 존재로 변경
  - TicketSeller가 TicketOffice의 자율권을 침해하므로 TicketOffice 역시 수정
    - TicketOffice의 자율성이 증가됐으나, TicketOffice의 Audience 의존성이 추가됨
    - 의존성의 추가는 높은 결합도를 의미하고, 높은 결합도는 변경하기 어려운 설계를 의미함.
  - 어떤 경우에도 모든 사람을 만족시킬 수 있는 설계를 만들 수는 없다.
  - 훌륭한 설계는 결국 트레이드오프의 결과물이다.
- 그래, 거짓말이다!
  - 앞서 다룬 Bag의 자율성 증가를 생각해보자.
  - 무생물 역시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급했다.
  - 의인화(anthropomorphism) : 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙
  - 훌륭한 객체지향 설계는 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.

### 1.4 객체지향 설계
- 설계 : 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.
- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 **변경을 매끄럽게 수용할 수 있는** 설계다.
- 변경에 유연하게 대응할 수 있는 코드를 설계하는 것이 중요
  - 요구사항은 항상 변경되고, 이에 맞춰 코드를 변경해야한다.
  - 코드를 변경할 때마다 버그가 추가될 가능성이 있다. 결국 변경에 유연하게 대응할 수 있는 코드를 설계하는 것이 중요
- 이해하기 쉬운 코드를 작성하는 것도 중요
  - 객체지향 패러다임은 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다.
- 훌륭한 객체지향 설계 : 협력하는 객체 사이의 의존성을 적절히 조절하는, 변경에 용이한 설계
  - 의존성 : 메시지를 전송하기 위한 지식이, 두 객체를 결합시키고 이 결합이 의존성을 만든다.
  - 객체간의 불필요한 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이 된다.
  - 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것

---

## Chapter 02. 객체지향 프로그래밍

### 2.1 영화 예매 시스템
요구사항 분석

- '영화' : 영화에 대한 기본 정보
- '상영' : 실제 관람객들이 영화를 관람하는 사건
- '영화'는 여러 일자에 거쳐, 하루 중 다양한 시간대에 한 번 이상 상영될 수 있다.
- 사용자는 적절한 대가를 지불하여 특정 시간대의 상영을 '예매'할 수 있다.
- '상영'에 여러 사람들이 '예매'할 수 있다.
- 각 '영화'는 할인 정책을 가지고 있고, 각각의 할인 정책마다 조건이 있다.
  - 할인 정책 : 얼마만큼 할인할 지를 결정하며, 할인 정책을 적용하기 위해서는 할인 조건 중 '하나'라도 만족해야한다.
  - 할인 정책은 금액 할인 정책, 비율 할인 정책 등이 있다.
    - 금액 할인 정책 : 예매 요금에서 일정 금액을 할인
    - 비율 할인 정책 : 예매 요금에서 일정 '비율'의 요금을 할인
  - 할인 정책을 지정하지 않을 수도 있다.
  - 할인 조건 : 기간 조건, 순번 조건, ...
    - 기간 조건 : 영화 상영 시작 시간을 이용해 할인 여부를 결정 (요일, 시작 시간, 종료 시간)
    - 순번 조건 : 매일 n번째로 상영되는 영화를 예매한 사용자들에게 할인 혜택을 제공
  - 할인 정책은 1인을 기준으로 책정되며, 예약인원이 2명이면 2명 모두 할인해줘야한다.
- 예매를 완료하면 시스템은 예매 정보를 생성해서 반환해야한다.


### 2.2 객체지향 프로그래밍을 향해
- 협력, 객체, 클래스
  - 객체지향은 '객체'를 지향하는 것이지, 클래스를 지향하는 것과는 거리가 멀다.
  - 진정한 객체지향 패러다임으로의 전환은 '객체'에 초점을 맞출 때에만 얻을 수 있다.
  - 객체 : 상태와 행동을 가지며, 시스템의 목적을 위해 다른 객체와 협력하고 스스로 자기 자신을 책임질 수 있는 존재.
  - 클래스 : 상태와 행동을 공유하는 객체들을 추상화한 것
  - 어떤 클래스가 필요한 지 고민하기 전에 어떤 객체들이 필요한 지 고민하라.
  - 객체를 독립적인 존재로 보지 말고, 협력하는 공동체의 일원으로 보자.
  - 협력관계, 객체 자신의 상태/행동 등을 고려하여 좋은 객체를 설계하고, 타입으로 분류하고 이 타입을 기반으로 클래스를 작성
  하자.
  - 훌륭한 협력이 훌륭한 객체를 낳고, 훌륭한 객체가 훌륭한 클래스를 낳는다.
- 도메인의 구조를 따르는 프로그램 구조 (도메인 주도 개발)
  - 도메인 : 사용자의 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
  - 객체지향 패러다임의 편리성
    - 요구사항 분석 ~ 프로그램 구현 단계까지 '객체'라는 동일한 추상화 기법을 사용할 수 있음
    - 도메인 모델을 기반으로 객체, 클래스를 매끄럽게 설계할 수 있음
  - 프로그램 작성
    - 클래스의 이름 : 대응되는 도메인 개념의 이름과 동일하거나 유사하게 이름을 지어야함
    - 클래스 간의 관계 : 도메인 개념과 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 함
    - 도메인 개념과 관계를 반영하도록 프로그램을 구조화해야하기 때문에 클래스의 구조는 도메인의 구조와 유사한 형태를
    띠어야 한다.
- 클래스 구현하기
  - 훌륭한 클래스를 설계하기 위한 핵심은, 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정하는 것이다.
    - 경계의 명확성이 객체의 자율성을 보장한다.
    - 프로그래머에게 구현의 자유를 제공한다.
  - 자율적인 객체
    - 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
    - 접근 제어 : 외부에서의 접근을 통제할 수 있는 메커니즘.
      - 접근 제어자(public, private, protected, ...)
    - 인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙
      - 퍼블릭 인터페이스 : 외부에서 접근 가능한 부분
      - 구현 : 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분
      - private 접근제어자 등으로 객체의 내부 상태는 은닉하고, public 접근제어자로 객체의 행동(퍼블릭 인터페이스)만 외부에 공개해야 함.
    - 객체지향의 핵심은 스스로의 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것.
    외부의 간섭을 최소화해야하고, 외부에서는 객체가 어떤 상태에 놓여 있는 지, 어떤 생각을 하고 있는 지 알아서는 안 되며
    결정에 직접적으로 개입하려고 해서도 안 된다.
  - 프로그래머의 자유
    - 클래스 작성자 : 접근 제어 -> 인터페이스와 구현 분리를 통한 구현 은닉 -> 내부 구현을 수정할 자유를 얻고, 변경의 파급효과 범위 제어
    - 클라이언트 프로그래머 : 내부 구현을 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의
    양을 줄일 수 있음.
    - 객체의 내부와 외부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클랠스 작성자가 자유롭게 구현을 변경할 수 있는
    폭이 넓어진다.
- 협력하는 객체들의 공동체
  - 자바 기본 타입 및 기본 API : 변수의 크기, 연산자 종류, 기본 API 등 구현 관점의 제약은 표현할 수 있으나 저장하는 데이터가 특정 도메인에
  연관되어 있다는 의미를 전달할 수 없다. 또, 관련 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없다.
  - Value Object : 의미를 좀 더 명시적이고 분명하게 표현할 수 있음. 하나의 인스턴스 변수만 포함하고 있더라도 개념을 명시적으로 표현할 수
  있다면 Value Object를 쓰는 것이 좋다.
  - 객체 지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 점이다.
  - Value Object와 같이 도메인의 의미를 풍부하게 표현할 수 있는 별도의 객체를 따로 정의하는 것은
  전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.
  - 협력(Colaboration) : 시스템의 어떤 기능을 구현하기 위애 객체들 사이에 이뤄지는 상호작용
  - 객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한 지 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를
  작성한다.
- 협력에 관한 짧은 이야기
  - 메시지 전송 : 객체가 다른 객체에 요청
  - 메시지 수신 : 요청 도착
  - 메서드 : 객체가 수신된 메시지를 처리하기 위한 자신만의 방법. 객체가 메시지를 처리하는 방법을 결정하는건 자신 스스로의 문제이다.
  - 메시지와 메서드를 명확히 구분하는 것에서 '다형성' 개념이 출발
  - 예) Screening은 Movie에게 'calculateMovieFee' 메시지를 전송한다. Screening은 Movie가 calculateMovieFee 메시지에 응답할 수
  있다고 믿고 메시지를 전송할 뿐이다. Movie 안에 calculateFee 메서드가 존재하는 지 여부 조자 알지 못 한다.

### 2.3 할인 요금 구하기
- Movie 안에는 어떤 DiscountPolicy를 사용할 것인 지 결정하는 코드가 존재하지 않는다. 오직 DiscountPolicy에게 메시지를 전송할 뿐이다.
- 무엇이 이를 가능하게 했는가? 이러한 객체지향 프로그래밍 방식의 기반에는 '상속', '다형성' 개념이 녹아있으며,
그 기반에는 '추상화'의 원리가 숨겨져 있다.
- 할인 정책과 할인 조건
  - 할인 정책 : 추상 클래스 DiscountPolicy에 기본적인 알고리즘을 두고, 중간에 필요한 처리를 하위 클래스에서 구현하게 했다.
    - 템플릿 메서드 패턴 : 부모 클래스에게 기본적인 알고리즘 흐름을 구현하고, 중간에 필요한 처리를 자식에게 위임하는 디자인 패턴
  - 할인 조건 : 인터페이스 DiscountPolicy에서 수신 가능한 메시지만을 명시하고, 메서드를 하위 클래스에서 구현하도록 했다.
  - 오버로딩과 오버 라이딩
    - 오버라이딩 : 부모 클래스에서 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의
    - 오버로딩 : 두 개 이상의 메서드가, 서로의 이름은 같지만 제공하는 파라미터의 목록이 다름. 이 경우 각각의 메서드들은 공존하며 외부에서는
    이 메서드들 모두를 호출할 수 있다.
- 할인 정책 구성하기
  - 하나의 영화에는 하나의 할인 정책만 설정할 수 있고, 하나의 할인 정책에는 여러 개의 할인 조건을 적용할 수 있다고 했는데, 이를 어떻게 보장
  할 수 있을까?
  - 생성자 사용법 : 생성자의 파라미터 목록을 이용해 초기에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장할 수 있다.

### 2.4 상속과 다형성

Movie 클래스 어디에서도 할인 정책이 금액 할인 정책인지, 비율 할인 정책인지 판단하지 않는다.  
단지 Movie에서 할인 정책에 메시지를 보낼 뿐인데, 이를 통해 어떻게 영화 최종 요금을 계산할 수 있었던 것일까?  
이 질문에 대답하기 위해서는 '상속', '다형성'의 개념을 확인해봐야 한다.

- 컴파일 시간 의존성과 실행 시간 의존성
  - 컴파일 시간 의존성(클래스 의존성) : 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나, 해당 클래스의 객체의 메서드를 호출할 경우
  두 클래스 사이에 의존성이 존재한다고 말한다.
  - 런타임 인스턴스 의존성 : 실제 실행시 Movie 인스턴스는 DiscountPolicy가 아닌 PercentDiscountPolicy 또는 AmountDiscountPolicy를
  의존하고 있다.
  - 클래스 사이의 의존성과 실제 런타임 객체 사이의 의존성은 동일하지 않을 수 있다. 유연하고 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계
  가 가지는 특징은 코드 의존성과 실행 시점의 의존성이 다르다.
  - 코드의 의존성과 실행 시간 의존성이 다르면 다를 수록 코드를 이해하기 어렵다.(코드를 이해하기 위해, 코드뿐 아니라 객체를 생성하고 연결하는
  부분을 찾아야하기 때문)
  - 코드의 의존성과 실행 시간 의존성이 다르면 다를 수록 코드는 더 유연하고 확장 가능해진다.
  - 코드의 의존성의 양면성을 통해 설계가 트레이드 오프의 산물임을 확인할 수 있다.
    - 설계가 유연해질 수록 코드를 이해하고, 디버깅하기는 더 어려워진다. 반변 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만
    재사용성과 확장 가능성은 낮아진다.
    - 무조건 유연한 설계도 무조건 읽기 쉬운 코드도 정답은 아니다. 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서
    고민해야한다.

- 차이에 의한 프로그래밍
  - 상속을 통해 클래스의 코드를 전혀 수정하지 않고, 하위 클래스에서 재사용하게 할 수 있다.
  - 상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.
  - 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
  - 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공한다.
  - 상속을 이용하면, 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.
  - 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 '차이에 의한 프로그래밍'이라고 부른다.
  - 용어
    - 부모, 자식 / 슈퍼, 서브 / 기반, 파생
    - 클래스 관계는 상대적이며 어느 클래스를 기준으로 하느냐에 따라 상속 관계에 참여하는 클래스의 역할이 달라진다.

- 상속과 인터페이스
  - 상속이 가치 있는 이유는 부모 클래스가 외부에 제공하는 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
  - 상속을 통해 자식 클래스는 부모 클래스의 인터페이스를 포함하게 된다. 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를
  수신할 수 있기 때문에 클라이언트는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
  - 클라이언트는 협력 객체가 자신이 송신하는 메시지를 이해할 수 있다면 그 객체가 어떤 클래스의 인스턴스인지 상관하지 않는다. 결국 자식 클래스는
  상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에, 부모 클래스 대신 사용될 수 있다.
    - 실제로 객체 지향 프로그래밍 언어의 컴파일러들은 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
  - 업캐스팅(upcasting) : 자식 클래스가 부모 클래스를 대신하는 것

- 다형성
  - 다형성 : 동일한 메시지를 수신했을 때, 객체의 타입에 따라 각각 다르게 응답할 수 있는 능력
    - 클라이언트는 동일한 메시지를 전송하지만, 수신 받는 객체가 이를 처리하는 메서드는 객체 자신의 클래스가 무엇인가에 따라 달라진다.
  - 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체 지향의 특성을 이용해, 서로 다른 메서드를 실행할 수 있게 한다.
  - 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야한다. 즉, 인터페이스가 동일해야한다.
  - 지연바인딩, 동적 바인딩
    - 메시지에 응답하기 위해 실행할 메서드를 컴파일 시점이 아닌 실행 시점에 바인딩하는 특징
      - 참고) 초기 바인딩, 정적 바인딩 : 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것
    - 지연바인딩을 통해, 컴파일 의존성과 실행타임 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있다.
  - 다형성과 상속
    - 다형성을 구현하는 방법은 다양하다. 상속은 다형성을 구현하는 방법 중 하나에 불과하다.
    - 상속을 통해, 동일한 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다.
  - 구현 상속과 인터페이스 상속
    - 구현 상속, 서브클래싱 : 순수하게 코드를 재사용하기 위한 상속
    - 인터페이스 상속, 서브타이핑 : 다형적인 협력을 통해 부모, 자식 클래스가 인터페이스를 공유하는 것
    - 상속은 구현 상속이 아닌 인터페이스 상속을 위해 사용해야한다. 인터페이스를 재사용할 목적이 아니라, 구현을 재사용할 목적으로
    상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.

- 인터페이스와 다형성
  - 구현 상속이 아닌, 순수하게 인터페이스만 공유하고 싶을 때가 있는데 이를 위해 java, C# 등에서는 '인터페이스'라는 프로그래밍 요소를 제공함
  - 예제 코드에서, 추상클래스를 통해 다형성을 구현했던 할인 정책과 다르게, 할인 조건은 자바의 인터페이스를 이용해 타입 계층을 구현했다.
  - 순번 할인 조건, 기간 할인 조건은 동일한 '할인조건' 인터페이스를 공유하며 '할인조건'으로서 업캐스팅하여 다형적인 협력에 참여할 수 있었다.

### 2.5 추상화와 다형성

- 추상화의 힘
  - 도메인의 주요 개념, 정책을 높은 수준에서 간단하게 표현할 수 있다.
    - 추상화를 이용하면, 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
    - 세부 사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있다.
    - 필요에 따라 표현의 수준을 조정하는 것을 가능하게 한다.
    - 추상화를 이용해 상위 정책을 기술하는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.
    - 자식 클래스들은 추상화를 이용해 정의한 상위의 협력 흐름을 그대로 따르게 된다.
    - 재사용 가능한 설계의 기본을 이루는 디자인 패턴, 프레임워크 역시 추상화를 이용해 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고 있다.
  - 기존 구조를 수정하지 않고 새로운 기능을 쉽게 추가, 확장하여 설계를 유연하게 할 수 있다.(이는 아래에서 더 자세히 다룬다.)
- 유연한 설계
  - 할인 정책이 없는 경우에만 조건문을 통해 분기처리할 경우 할인 금액을 결정하는 책임이 Movie에게 이동하게 됨. 
  결국 기존의 일관성 있는 협력 방식이 무너짐.
    - 책임의 위치를 결정하기 위해 조건문을 사용하여 특수한 경우에만 분기처리하는 것은 협력의 설계 측면에서 좋지 않은 선택이 됨.
    - 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하자.
  - NoneDiscountPolicy를 구현하여 일관성을 유지할 수 있음. 기존의 코드를 수정하지 않고, 새로운 클래스를 추가하는 것만으로 애플리케이션의 기능을
  확장한 것이다.
  - 추상화를 통해, 설계가 구체적인 상황에 결합되는 것을 방지하고 유연한 설계를 가능하게 한다.
  - 특정 구현체에 의존하지 않고 추상적인 대상을 의존한 덕분에 유연한 설계가 가능해졌는데 이런 개념은 8장의 '컨텍스트 독립성'에서 다룰 것
    - 이 개념은 프레임워크와 같은 유연한 설계가 필수적인 분야에서 진가를 발휘함

- 추상클래스와 트레이드 오프
  - NoneDiscountPolicy의 `getDiscountAmount()` 메서드가 어떤 값을 반환하더라도 관계가 없다. 상위 클래스인 DiscountPolicy의
  `calculateDiscountAmount()`로 인해 결국 0원이 할인된다.
  - NoneDiscountPolicy는 상속으로 인해 상위 추상 클래스인 DiscountPolicy와 강하게 개념적으로 결합되는 문제가 발생했다.
  - 이런 문제를 해결하기 위해 DiscountPolicy를 인터페이스로 하고, 하위에 DefaultDiscountPolicy, NoneDiscountPolicy를 두었다.
  - NoneDiscountPolicy- DiscountPolicy의 강결합 문제되어 좀 더 설계가 유연해졌으나, 전반적인 복잡도가 증가하였다. 이것은 결국 트레이드 오프다. 
  - 우리가 작성하는 모든 코드에는 합당한 이유가 있어야하며, 사소한 결정이더라도 트레이드 오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의
  차이는 매우 크다. 고민하고 트레이드 오프를 하자.

- 코드 재사용
  - 코드를 재사용하는 방법으로는 크게 두가지, 상속과 합성이 있다.
  - 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
  - Movie가 DiscountPolicy를 인스턴스 변수로 하여 DiscountPolicy의 코드를 재사용하는 방법이 바로 합성이다.
  - 사람들이 상속 대신 합성을 더 선호하는 이유는? (아래에서 서술)

- 상속
  - 상속은 두 가지 관점에서 설계에 악영향을 끼친다.
    - 캡슐화 위반
    - 설계를 유연하지 못 하게 한다.
  - 캡슐화 위반
    - 상속을 사용하기 위해서는, 부모의 내부 구조를 잘 알고 있어야한다.
    - 하위 클래스 개발자는 부모 클래스의 맥락을 알고 있어야한다.
    - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    - 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에, 부모 클래스가 변경될 때 자식 클래스도 함께 변경될 확률을 높인다.
    - 상속을 과도하게 사용한 코드는 변경하기 더 어려워진다.
  - 설계를 유연하지 못 하게 함
    - 부모-자식 클래스 관계가 컴파일 시점에 결정됨으로 인해 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
    - 런타임에 객체의 종류를 변경하려면, 다른 인스턴스를 생성하고 프로퍼티를 복사해서 생성해야함.
    - 이 역시 부모-자식 클래스가 강하게 결합되어 있기 때문에 발생함
  - 상속의 예 : Movie -> (상속) AmountDiscountMovie, PercentDiscountMovie
    - 런타임의 Movie 인스턴스의 타입을 변경하기 매우 힘들어짐
    - 상속보다 인스턴스 변수로 관계를 연결하면 원래 설계가 더 유연해짐 (changeDiscountPolicy)
- 합성
  - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용함
  - 인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에, 구현을 효과적으로 캡슐화
  - 의존하는 인터페이스를 교체하는 것이 쉽기 때문에 설계를 유연하게 함.
  - 상속은 상위 클래스와 강하게 결합되는 데에 비해, 합성은 메시지를 통해 느슨하게 결합됨.
  - 따라서 코드의 재사용을 목적으로 한다면 상속을 사용하기 보다 합성을 선호하는 것이 더 좋다.
  - 하지만 모든 상황에서 합성만을 사용해야하는 것은 아니다. 상황에 맞게 적절하게 합성과 상속을 함께 사용해야한다.
    - 이전의 DefaultDiscountPolicy의 사례와 같이 다형성을 위해 인터페이스를 재사용을 하는 경우에는 합성, 상속을 함께 사용해야함.


### 마치며
- 프로그래밍 관점에서 클래스, 상속은 중요하지만 프로그래밍 관점에 치우쳐서 객체지향을 바라볼 경우 객체지향의 본질을 놓치기 쉽다.
- 객체지향은 객체를 지향하는 것이고, 객체지향 패러다임의 중심에는 객체가 위치한다. 객체지향에서 가장 중요한 것은 애플리케이션의 기능을
구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다.
- 객체지향 설계의 핵심은 적절한 협력을 식별하고, 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을
할당하는 것이다.

---

## Chapter 03. 역할, 책임, 협력

### Intro
- 객체지향 설계의 본질은 협력하는 객체들의 공동체를 창조하는 것
- 객체지향 설계의 핵심 : 협력을 구성하기 위해 적절한 객체를 찾고, 적절한 책임을 할당하는 과정
- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요한 지, 협력을 위해 어떤 역할과 책임이 필요한지, 구분하지 않은 채
구현에 초점을 두면 변경하기 어렵고 유연하지 못 한 코드를 낳는 원인이 됨.


### 3.1 협력
- 영화 예매 시스템 돌아보기
  - 영화 예매 시스템 : 객체 지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고,다양한 객체들 사이에 균형 있게 분배됨
  - 협력 : 다양한 객체들이, 공통의 목적에 해당하는 애플리케이션 기능을 구현하기 위해 수행하는 상호작용
  - 책임 : 객체가 협력에 참여하기 위해 수행하는 로직
  - 역할 : 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 '역할'이 됨.

- 협력
  - 객체는 고립된 존재가 아니라, 시스템의 '기능'이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적 존재
  - 협력은 객체 지향 세계에서 기능을 구현할 수 있는 유일한 방법
  - 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.
  - 메시지 전송 : 객체가 다른 객체에게 도움을 요청
  - 메서드 : 객체가 다른 객체가 보낸 메시지를 수신받고 스스로 처리하는 방법
    - 수신받은 메시지를 어떻게 처리할 지는, 수신한 객체 스스로 직접 결정한다. 이는 객체가 자신의 일을 스스로 처리할 수 있는
    자율적인 존재라는 것을 의미한다.
  - 자율적인 객체들의 협력
    - 객체의 자율성을 보장하기 위해서는, 필요한 정보와 정보에 기반한 행동을 같은 객체 않에 모아두어야 함
    - 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있음.
    - 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는 것.
    - 내부 구현에 직접 접근하는 것은 캡슐화 원칙을 위반
  - 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에, 필요한 정보를 알지 못 하거나 외부의 도움이 필요한 경우 적절한 객체에게
  메시지를 전송해서 협력을 요청
  - 객체들 사이의 협력을 구성하는 일련의 요청, 응답의 흐름을 통해 애플리케이션의 기능이 구현됨
  
- 협력이 설계를 위한 문맥을 결정한다.
  - 객체의 존재 이유, 객체의 '행동'의 전제 조건 : 협력
    - 객체가 존재하는 것은 어떤 '협력'에 참여하고 있기 때문이다.
    - 객체가 '협력'에 참여할 수 있는 이유는 협력에 필요한 적절한 '행동'을 보유하고 있기 때문이다.
    - 객체의 행동을 결정하는 것은 결국 애플리케이션 맥락 관점에서, 객체가 참여하고 있는 '협력'이다.
    - '협력'이 변하면 객체가 제공하는 행동 역시 바뀌어야함.
    - '협력'은 객체가 필요한 이유, 객체가 수행하는 행동의 동기를 제공함.
    - '협력'이라는 문맥을 고려하지 않고 객체의 행동을 결정하는 것은 아무런 의미가 없다.
  - 객체의 상태를 결정하는 것 : 행동
    - 객체가 행동을 하는데 필요한 정보가 무엇인가?
    - 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에, 객체가 수행하는 행동에 필요한
    상태도 스스로 함께 가지고 있어야한다.
  - 결국 객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다.
    - 협력은 객체를 설계하는 데 필요한 '문맥(context)'를 제공한다.
    - 행동은 협력 안에서 객체가 처리할 메시지로 결정된다.
    - 상태는 객체가 행동하는데 필요한 정보에 의해 결정된다. 

---

## Chapter 04. 설계 품질과 트레이드오프

---

## Chapter 05. 책임 할당하기

---

## Chapter 06. 메시지와 인터페이스

---

## Chapter 07. 객체 분해

---

## Chapter 08. 의존성 관리하기

---

## Chapter 09. 유연한 설계

---

## Chapter 10. 상속과 코드 재사용

---

## Chapter 11. 합성과 유연한 설계

---

## Chapter 12. 다형성

---

## Chapter 13. 서브클래싱과 서브타이핑

---

## Chapter 14. 일관성 있는 협력


---

## Chapter 15. 디자인 패턴과 프레임워크

---

## Appendix A. 계약에 의한 설계

---

## Appendix B. 타입 계층의 구현

---

## Appendix C. 동적인 협력, 정적인 코드

---
