# 오브젝트

- 조영호 님의 서적 [오브젝트](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=193681076) 정리

---

# Chapter 01. 객체, 설계

- 이론보다 실무가 먼저 : 프로그래밍을 통해 개념과 이론을 배우는 것이 더 훌륭한 학습 방법

## 1.1 티켓 판매 애플리케이션 구현하기
- Theater가 audience의 bag, ticketSeller의 TicketOffice를 알고 있음
- 애플리케이션 로직이 Theater에 집중되어있음

## 1.2 무엇이 문제인가
> 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야한다.

- 제대로 실행은 되지만, 변경이 쉽지 않고, 이해하기 어렵다.
- 읽기 어려운 코드, 예상을 벗어나는 코드
  - Audience, TicketSeller가 Theater의 통제를 받는 수동적인 존재
  - 코드의 맥락을 읽어보면 우리의 상식과 너무 다르게 동작하기 때문에 코드를 읽는 다른 사람과 제대로 의사소통하기 어렵다.
  - 하나의 클래스, 메서드에서 너무 많은 세부사항을 다루기 때문에 코드 작성자 뿐 아니라 코드를 이해해야하는 사람 모두에게 큰 부담을 줌
- 변경에 취약한 코드
  - 다른 클래스가 Audience의 내부에 대해 더 많이 알면 알 수록 Audience를 더 변경하기 어려워짐
  - 의존성 -> 변경에 대한 암시 -> 어떤 객체가 변경될 때 이를 의존하는 다른 객체도 함께 변경될 수 있다 
    - 결합도(coupling) : 객체 사이의 의존성이 과하다 = 결합도가 높다.
  - 그러나 의존성을 완전히 없애는 것이 정답은 아니다. 결국 만들고자 하는 것은 협력하는 객체들의 공동체를 구축하는 것.
  현실적인 목표로, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것을 두자
  - 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것을 목표로 두자.

## 1.3 설계 개선하기
- 문제점
  - 어떤 객체가 자기 자신의 일을 스스로 처리하지 못 하는 것은 우리의 직관을 벗어난다.
    - 우리의 의도를 정확하게 의사소통하지 못 하기 때문에 이해하기 어려운 코드가 됐다.
  - 불필요한 의존성이 발생하여 결합도가 높아지고, 변경의 파급효과가 커짐으로서 변경하기 어려운 코드가 됨
- 자율성을 높이자
  - 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임짐으로서 객체를 자율적인 존재로 만듬
  - 캡슐화(encapsulation) : 개념적으로, 물리적으로 객체 내부의 세부적인 사항을 감추는 것
    - 캡슐화의 목표는 변경하기 쉬운 객체를 만드는 것
    - 객체 내부의 세세한 부분까지 알지 못 하도록 정보에 대한 접근을 제한함으로서, 객체간 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게
    변경할 수 있게 됨
  - 객체를 인터페이스(interface)와 구현(implemenation)으로 나누고 인터페이스만을 공개하는 것은 객체 간의 결합도를 낮추고
  변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙
- 무엇이 개선됐는가
  - TicketSeller, Audience는 자신의 데이터를 스스로 관리함
    - 우리의 예상과 정확히 일치함 -> 코드를 읽는 사람과의 의사소통 관점에서 개선됨
    - Audience, TicketSeller 내부 구현을 변경하더라도 Theater를 변경할 필요가 없어짐
- 어떻게 한 것인가
  - 불필요한 내부 구현을 은닉하고, 객체 스스로 자기 자신의 문제를 스스로 해결하도록 코드로 변경
  - 덕분에 이해하기 쉽고, 변경에 유연한 설계를 얻을 수 있었다.
- 캡슐화, 응집도
  - 핵심 : 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것
  - 응집도(cohension) : 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에에 위임하는 객체는 응집도가 높다.
  - 자율적인 객체를 만들면 결합도를 낮출 수 있고, 응집도를 높일 수 있다.
  - 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임지고 처리할 수 있는 자율적인 존재로 만드는 것.
  - 외부의 간섭을 최대한 배제하고, 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를
  얻을 수 있는 지름길
- 절차지향과 객체지향
  - 절차적 프로그래밍(Procedural Programming) : 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
    - 우리의 직관에 위배됨
    - 코드를 읽는 사람과 원활하게 의사소통하지 못함
    - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.
    - 변경하기 어려운 코드를 양산하는 경향이 있음
  - 객체지향 프로그래밍(Object-Oriented Prgramming) : 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
    - 훌륭한 객체지향 설계의 핵심 : 캡슐화를 통해 의존성을 적절히 관리함으로서 객체 사이의 결합도를 낮추는 것
- 책임의 이동
  - 책임의 집중 : 책임이 한 곳에 집중됨 -> 일반적인 절차적 프로그래밍 방식
    - 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있을 경우 절차적 프로그래밍 방식을 따르고 있을 확률이 크다. 
  - 책임의 이동, 분산 : 각 객체에 적절한 책임이 분배 -> 각 객체는 객체 자신을 스스로 책임짐
    - 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 분산하여 할당하는 것
    - 객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당하느냐에 초점을 맞춰야한다
  - 불필요한 의존성을 제거하고, 결합도를 낮춰라.
    - 설계를 어렵게 만드는 것은 불필요한 의존성.
    - 불필요한 세부사항을 캡슐화하는 **자율적인 객체들**(책임의 분산)이 낮은 결합도와 높은 응집도를 가지고 협력하도록,
    최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계 
- 더 개선할 수 있다
  - Bag을 자율적인 존재로 변경
  - TicketSeller가 TicketOffice의 자율권을 침해하므로 TicketOffice 역시 수정
    - TicketOffice의 자율성이 증가됐으나, TicketOffice의 Audience 의존성이 추가됨
    - 의존성의 추가는 높은 결합도를 의미하고, 높은 결합도는 변경하기 어려운 설계를 의미함.
  - 어떤 경우에도 모든 사람을 만족시킬 수 있는 설계를 만들 수는 없다.
  - 훌륭한 설계는 결국 트레이드오프의 결과물이다.
- 그래, 거짓말이다!
  - 앞서 다룬 Bag의 자율성 증가를 생각해보자.
  - 무생물 역시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급했다.
  - 의인화(anthropomorphism) : 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙
  - 훌륭한 객체지향 설계는 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.

### 1.4 객체지향 설계
- 설계 : 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.
- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 **변경을 매끄럽게 수용할 수 있는** 설계다.
- 변경에 유연하게 대응할 수 있는 코드를 설계하는 것이 중요
  - 요구사항은 항상 변경되고, 이에 맞춰 코드를 변경해야한다.
  - 코드를 변경할 때마다 버그가 추가될 가능성이 있다. 결국 변경에 유연하게 대응할 수 있는 코드를 설계하는 것이 중요
- 이해하기 쉬운 코드를 작성하는 것도 중요
  - 객체지향 패러다임은 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다.
- 훌륭한 객체지향 설계 : 협력하는 객체 사이의 의존성을 적절히 조절하는, 변경에 용이한 설계
  - 의존성 : 메시지를 전송하기 위한 지식이, 두 객체를 결합시키고 이 결합이 의존성을 만든다.
  - 객체간의 불필요한 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이 된다.
  - 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것

---

## Chapter 02. 객체지향 프로그래밍

---

## Chapter 03. 역할, 책임, 협력

---

## Chapter 04. 설계 품질과 트레이드오프

---

## Chapter 05. 책임 할당하기

---

## Chapter 06. 메시지와 인터페이스

---

## Chapter 07. 객체 분해

---

## Chapter 08. 의존성 관리하기

---

## Chapter 09. 유연한 설계

---

## Chapter 10. 상속과 코드 재사용

---

## Chapter 11. 합성과 유연한 설계

---

## Chapter 12. 다형성

---

## Chapter 13. 서브클래싱과 서브타이핑

---

## Chapter 14. 일관성 있는 협력


---

## Chapter 15. 디자인 패턴과 프레임워크

---

## Appendix A. 계약에 의한 설계

---

## Appendix B. 타입 계층의 구현

---

## Appendix C. 동적인 협력, 정적인 코드

---
