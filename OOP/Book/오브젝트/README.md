
# 오브젝트

---

## Intro 프로그래밍 패러다임

---

## Chapter 01. 객체, 설계
### 1.1 티켓 판매 애플리케이션 구현하기
### 1.2 무엇이 문제인가
### 1.3 설계 개선하기
### 1.4 객체지향 설계

## Chapter 02. 객체지향 프로그래밍
### 2.1 영화 예매 시스템
### 2.2 객체지향 프로그래밍을 향해
### 2.3 할인 요금 구하기
### 2.4 상속과 다형성
### 2.5 추상화와 유연성

## Chapter 03. 역할, 책임, 협력
### 3.1 협력
### 3.2 책임
### 3.3 역할

## Chapter 04. 설계 품질과 트레이드오프
### 4.1 데이터 중심의 영화 예매 시스템
### 4.2 설계 트레이드오프
### 4.3 데이터 중심의 영화 예매 시스템의 문제점
### 4.4 자율적인 객체를 향해
### 4.5 하지만 여전히 부족하다

## Chapter 05. 책임 할당하기
### 5.1 책임 주도 설계를 향해
### 5.2 책임 할당을 위한 GRASP 패턴
### 5.3 구현을 통한 검증
### 5.4 책임 주도 설계의 대안

## Chapter 06. 메시지와 인터페이스
### 6.1 협력과 메시지
### 6.2 인터페이스와 설계 품질
### 6.3 원칙의 함정
### 6.4 명령-쿼리 분리 원칙

## Chapter 07. 객체 분해
### 7.1 프로시저 추상화와 데이터 추상화
### 7.2 프로시저 추상화의 기능 분해
### 7.3 모듈
### 7.4 데이터 추상화와 추상 데이터 타입
### 7.5 클래스

## Chapter 08. 의존성 관리하기
### 8.1 의존성 이해하기
### 8.2 유연한 설계

## Chapter 09. 유연한 설계
### 9.1 개방-폐쇄 원칙
### 9.2 생성 사용 분리
### 9.3 의존성 주입
### 9.4 의존성 역전 원칙
### 9.5 유연성에 대한 조언

## Chapter 10. 상속과 코드 재사용
### 10.1 상속과 중복 코드
### 10.2 취약한 기반 클래스 문제
### 10.3 Phone 다시 살펴보기
### 10.4 차이에 의한 프로그래밍

## Chapter 11. 합성과 유연한 설계
### 11.1 상속을 합성으로 변경하기
### 11.2 상속으로 인한 조합의 폭발적인 증가
### 11.3 합성 관계로 변경하기
### 11.4 믹스인

## Chapter 12. 다형성
### 12.1 다형성
### 12.2 상속의 양면성
### 12.3 업캐스팅과 동적 바인딩
### 12.4 동적 메서드 탐색과 다형성
### 12.5 상속 대 위임

## Chapter 13. 서브클래싱과 서브타이핑
### 13.1 타입
### 13.2 타입 계층
### 13.3 서브클래싱과 서브타이핑
### 13.4 리스코프 치환 원칙
### 13.5 계약에 의한 설계와 서브타이핑

## Chapter 14. 일관성 있는 협력
### 14.1 핸드폰 과금 시스템 변경하기
### 14.2 설계에 일관성 부여하기
### 14.3 일관성 있는 기본 정책 구현하기

## Chapter 15. 디자인 패턴과 프레임워크
### 15.1 디자인 패턴과 설계 재사용
### 15.2 프레임워크와 코드 재사용

---

## 부록 A. 계약에 의한 설계
### A.1 협력과 계약
### A.2 계약에 의한 설계
### A.3 계약에 의한 설계와 서브타이핑

## 부록 B. 타입 계층의 구현
- 클래스를 이용한 타입 계층 구현
- 인터페이스를 이용한 타입 계층 구현
- 추상 클래스를 이용한 타입 계층 구현
- 추상 클래스와 인터페이스 결합하기
- 덕 타이핑 사용하기
- 믹스인과 타입 계층

## 부록 C. 동적인 협력, 정적인 코드
### C.1 동적 모델과 정적 모델
### C.2 도메인 모델과 구현

---
