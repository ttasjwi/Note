
# 스프링 핵심 원리 - 고급편

---

## Chapter 01. 예제 만들기
### <a href="Chapter 01. 예제 만들기/1.1 프로젝트 생성.md">1.1 프로젝트 생성</a>
1) 프로젝트 생성
2) IDE 설정
3) 실행 확인

### <a href="Chapter 01. 예제 만들기/1.2 예제 프로젝트 만들기 - V0.md">1.2 예제 프로젝트 만들기 - V0</a>
1) `OrderRepositoryV0` : 리포지토리
2) `OrderServiceV0` : 서비스
3) `OrderControllerV0` : 컨트롤러
4) 실행 확인

### <a href="Chapter 01. 예제 만들기/1.3 로그 추적기 - 요구사항 분석.md">1.3 로그 추적기 - 요구사항 분석</a>
1) 문제 상황 : 모든 로직, 예외 발생 상황에 로그 작성
2) 세부 요구사항 및 예시

### <a href="Chapter 01. 예제 만들기/1.4 로그 추적기 V1 - 프로토타입 개발.md">1.4 로그 추적기 V1 - 프로토타입 개발</a>
1) TraceId - 트랜잭션의 Id, 깊이
2) TraceStatus : 로그의 상태 정보
3) HelloTraceV1 : 프로토타입 로그 추적기
4) HelloTraceV1Test : 테스트

### <a href="Chapter 01. 예제 만들기/1.5 로그 추적기 V1 - 적용.md">1.5 로그 추적기 V1 - 적용</a>
1) `v0` -> `v1`
2) 각 계층마다 로그 추적기 의존관계 추가
3) 각 메서드 시작/종료 시점에 로그 추적기 코드 실행 - V1 적용
4) 실행 및 로그 확인
5) 남은 문제 : 메서드 깊이 표현, HTTP 요청 구분

### <a href="Chapter 01. 예제 만들기/1.6 로그 추적기 V2 - 파라미터로 동기화 개발.md">1.6 로그 추적기 V2 - 파라미터로 동기화 개발</a>
1) `HelloTraceV2.beginSync` : TraceId를 파라미터로 전달받아 동기화
2) HelloTraceV2Test

### <a href="Chapter 01. 예제 만들기/1.7 로그 추적기 V2 - 적용.md">1.7 로그 추적기 V2 - 적용</a>
1) `v1` -> `v2` 복사
2) V2 적용하기 : 메서드마다 traceId 파라미터 추가
3) 실행 및 로그 분석
4) 파라미터를 수정하지 않고 TraceId를 동기화할 방법이 필요

---

## Chapter 02. 스레드 로컬 - ThreadLocal

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.1 필드 동기화 - 개발.md">2.1 필드 동기화 - 개발</a>
1) 아이디어 : 로그 추적기의 필드에서 `TracaeId`를 공유하고, 동기화
2) `LogTrace` 인터페이스
3) `FieldLogTrace` : 파라미터를 넘기지 않고 필드에서 TraceId 동기화
4) `FieldLogTrace` 사용 흐름
5) `FieldLogTraceTest` : 필드 로그 추적기 테스트

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.2 필드 동기화 - 적용.md">2.2 필드 동기화 - 적용</a>
1) `LogTraceConfig` : `LogTrace`를 수동 빈 등록할 `Configuration`
2) `v2` -> `v3` 코드 수정
3) 실행 및 로그 분석

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.3 필드 동기화 - 동시성 문제.md">2.3 필드 동기화 - 동시성 문제</a>
1) 필드 동기화의 심각한 문제 확인 : 여러 요청이 동시에 들어올 때?
2) 기대하는 결과 : 각 요청 스레드마다 올바른 로그 출력
3) 실제 결과 - 여러 요청(스레드)이 같은 TraceId를 공유하고, 로그가 꼬임
4) 동시성 문제 : 싱글톤 인스턴스의 공유 변수 동시 접근

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.4 동시성 문제 - 예제 코드.md">2.4 동시성 문제 - 예제 코드</a>
1) `FieldService` : `nameStore`에 `name`을 저장하고 조회하는 로직
2) (실습) 동시성 문제 없는 코드
3) (실습) 동시성 문제 발생 코드
4) 동시성 문제 : 여러 스레드가 같은 인스턴스, static 필드를 변경 후 조회하면서 발생

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.5 ThreadLocal - 소개.md">2.5 ThreadLocal - 소개</a>
1) 기존 : 일반적인 변수 필드에 여러 스레드가 데이터를 저장하는 방식
2) 스레드 로컬 : 각 스레드마다 할당된 특별한 저장소
3) 스레드 로컬 : 흐름

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.6 ThreadLocal - 예제 코드.md">2.6 ThreadLocal - 예제 코드</a>
1) (실습) `ThreadLocalService` : ThreadLocal에 `name`을 저장하고 조회하는 로직
2) ThreadLocal 사용법
3) ThreadLocalServiceTest : 동시성 문제 해결

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.7 스레드 로컬 동기화 - 개발.md">2.7 스레드 로컬 동기화 - 개발</a>
1) `ThreadLocalLogTrace` : 로그 추적기에 스레드 로컬 적용
2) `ThreadLocal`을 모두 사용한 후 반드시 remove를 호출해서 저장 값을 제거해야한다.
3) `ThreadLocalLogTraceTest` : 테스트 실행

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.8 스레드 로컬 동기화 - 적용.md">2.8 스레드 로컬 동기화 - 적용</a>
1) 로그 추적기 구현체 빈을 `ThreadLocalLogTrace`로 변경
2) 실행 확인
3) 동시성 문제 해결 확인

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.9 스레드 로컬 - 주의사항.md">2.9 스레드 로컬 - 주의사항</a>
1) 스레드 로컬 사용 후 저장 값 제거를 안 하면, 사용자 정보 유출 위험이 있다.
2) 스레드 로컬 사용 후 반드시 `remove`를 호출 하자.

---

## Chapter 03. 템플릿 메서드 패턴과 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.01 템플릿 메서드 패턴 - 시작.md">3.01 템플릿 메서드 패턴 - 시작</a>
1) 로그 추적기를 도입하니, 핵심기능에 부가기능이 잔뜩 붙어서 코드 복잡도가 많이 증가됐다.
2) 핵심 기능, 부가 기능
3) 동일한 패턴이 존재하는데 이를 공통화 할 방법이 없을까?
4) 변하는 것과 변하지 않는 것을 분리해야한다.
5) 해결책 : 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.02 템플릿 메서드 패턴 - 예제1.md">3.02 템플릿 메서드 패턴 - 예제1</a>
1) `templateMethodV0()` : 비즈니스 로직만 다르고 나머지는 모두 같은 두 코드
2) 변하는 부분, 변하지 않는 부분

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.03 템플릿 메서드 패턴 - 예제2.md">3.03 템플릿 메서드 패턴 - 예제2</a>
1) 템플릿 메서드 패턴(Template Method Pattern)
2) 추상 클래스를 통해 전체 틀을 정해두고, 변하는 부분을 하위 클래스에서 구현한다.
3) `templateMethodV1` : 템플릿 메서드 패턴 적용
4) 템플릿 메서드 패턴의 인스턴스 호출 과정

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.04 템플릿 메서드 패턴 - 예제3.md">3.04 템플릿 메서드 패턴 - 예제3</a>
1) 익명 내부 클래스 사용하기
2) `templateMethodV2()` - 템플릿 메서드 패턴에서 익명 내부 클래스를 사용

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.05 템플릿 메서드 패턴 - 적용1.md">3.05 템플릿 메서드 패턴 - 적용1</a>
1) `AbstractTemplate` : 로그 추적 템플릿
2) `v3` -> `v4` 복사
3) 애플리케이션 수정 : 템플릿 메서드 패턴 적용
4) 실행 확인

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.06 템플릿 메서드 패턴 - 적용2.md">3.06 템플릿 메서드 패턴 - 적용2</a>
1) 지금까지 작성한 코드 비교
2) 좋은 설계 : 변경에 쉽게 대처할 수 있는 코드
3) 템플릿 메서드 패턴과 단일 책임 원칙(SRP)

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.07 템플릿 메서드 패턴 - 정의.md">3.07 템플릿 메서드 패턴 - 정의</a>
1) 템플릿 메서드 패턴의 정의
2) 템플릿 메서드 패턴의 문제점 : 상속과 강한 결합
3) 개선안 : 전략 패턴, 템플릿 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.08 전략 패턴 - 시작.md">3.08 전략 패턴 - 시작</a>
1) 예제 생성 : `ContextV1Test`

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.09 전략 패턴 - 예제1.md">3.09 전략 패턴 - 예제1</a>
1) 템플릿 메서드 패턴 vs 전략 패턴
2) `ContextV1`, `Strategy` : 전략 패턴 예제 코드
3) `strategyV1()` : 전략 패턴 적용 예제 코드 실행
4) 전략 패턴 실행 흐름
5) 스프링과 전략 패턴의 공통점

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.10 전략 패턴 - 예제2.md">3.10 전략 패턴 - 예제2</a>
1) `strategyV2()` : 전략 패턴에 익명 내부 클래스 사용
2) `strategyV3()` : 전략 익명 내부 클래스를 생성과 동시에 인자로 전달
3) `strategyV4()` : 전략을 람다로 구현해서 전달
4) 일반적인 전략 패턴 : 선 조립 후 실행
5) 일반적인 전략 패턴의 단점 : 조립 이후 전략 변경이 번거롭다.

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.11 전략 패턴 - 예제3.md">3.11 전략 패턴 - 예제3</a>
1) `ContextV2` : 전략을 파라미터로 전달받는 방식
2) `ContextV2Test.strategyV1()` : 메서드 파라미터로 전략 전달
3) 전략 패턴 - 파라미터로 전략 전달 시 실행 흐름
4) `ContextV2Test.strategyV2()` : 메서드 파라미터로 전략 전달(익명 내부 클래스)
5) `ContextV2Test.strategyV2()` : 메서드 파라미터로 전략 전달(람다)
6) 필드에 전략을 전달하기 vs 메서드 파라미터로 전략을 전달하기
7) 템플릿의 작은 변하는 부분에 사용할 다른 코드 조각을 넘기는 것

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.12 템플릿 콜백 패턴 - 시작.md">3.12 템플릿 콜백 패턴 - 시작</a>
1) 콜백(Callback)
2) 템플릿 콜백 패턴(Template Callback Pattern)

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.13 템플릿 콜백 패턴 - 예제.md">3.13 템플릿 콜백 패턴 - 예제</a>
1) 앞서 구현한 파라미터 전략 전달 방식과 구조적으로 동일하다.
2) `Callback` : 템플릿의 메서드 파라미터로 전달되는 코드 조각(전략)
3) `TimeLogTemplate` : 템플릿
4) `TemplateCallbackTest` : 템플릿 콜백 패턴 적용 테스트

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.14 템플릿 콜백 패턴 - 적용.md">3.14 템플릿 콜백 패턴 - 적용</a>
1) `TraceCallback` : 로그 추적 템플릿에 전달할 콜백
2) `TraceTemplate` : 로그 추적 템플릿
3) `v4` -> `v5` 복사
4) 각 계층에서 `TraceTemplate`를 의존하게 변경
5) 애플리케이션에 템플릿 콜백 패턴 적용
6) 실행 확인
7) 최적화를 통해 변하는 코드, 변하지 않는 코드를 분리하는데 성공했다.
8) 한계 : 결국 원본 코드를 수정해야한다.

---

## Chapter 04. 프록시 패턴과 데코레이터 패턴
### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.01 프로젝트 생성.md">4.01 프로젝트 생성</a>
1) 프로젝트 설정

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.02 예제 프로젝트 만들기 v1.md">4.02 예제 프로젝트 만들기 v1</a>
1) 앞으로 만들 예제들 - 개요
2) `v1` - 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.03 예제 프로젝트 만들기 v2.md">4.03 예제 프로젝트 만들기 v2</a>
1) `v2` - 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.04 예제 프로젝트 만들기 v3.md">4.04 예제 프로젝트 만들기 v3</a>
1) `v3` - 컴포넌트 스캔으로 스프링 빈 자동 등록

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.05 요구사항 추가.md">4.05 요구사항 추가</a>
1) 기존 요구사항
2) 기존 방식의 한계 : 핵심 기능 코드를 건들 수밖에 없음
3) 요구사항 추가 : 원본 코드를 수정하지 않고 로그 추적기 적용
4) 해결책 : 프록시 개념 이해, 프록시 패턴/데코레이터 패턴 이해

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.06 프록시, 프록시 패턴, 데코레이터 패턴 - 소개.md">4.06 프록시, 프록시 패턴, 데코레이터 패턴 - 소개</a>
1) 클라이언트와 서버 : 요청하는 측, 요청을 처리하는 측
2) 직접 호출, 프록시를 통한 간접 호출
3) 프록시 체인 : 프록시는 여러 개를 둘 수 있다
4) 프록시는 서버와 같은 인터페이스를 구현하고, 대체하여 주입된다.
5) 프록시의 주요기능 : 접근제어, 부가 기능 추가
6) 프록시, 프록시 패턴, 데코레이터 패턴

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.07 프록시 패턴 - 예제 코드1.md">4.07 프록시 패턴 - 예제 코드1</a>
1) 테스트 환경 준비
2) 예제 코드 : 프록시 패턴 적용 전
3) 실행 및 로그 분석 : 동일한 작업을 세번 반복

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.08 프록시 패턴 - 예제 코드2.md">4.08 프록시 패턴 - 예제 코드2</a>
1) 예제 코드 : 프록시 패턴 적용 후
2) 실행 및 로그 분석 : 프록시의 캐싱을 통한 성능 개선
3) 정리 : 클라이언트와 서버의 코드 변경 없이, 프록시를 도입해서 접근 제어

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.09 데코레이터 패턴 - 예제 코드1.md">4.09 데코레이터 패턴 - 예제 코드1</a>
1) 예제 코드 : 데코레이터 패턴 적용 전
2) 실행 확인 : RealComponent가 반환한 원본 값 그대로 받음

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.10 데코레이터 패턴 - 예제 코드2.md">4.10 데코레이터 패턴 - 예제 코드2</a>
1) 데코레이터 패턴 : 프록시를 통해 부가기능 추가
2) 예제 코드 : 응답 값을 꾸며주는 데코레이터
3) 실행 : 데코레이터를 통해 부가기능을 추가

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.11 데코레이터 패턴 - 예제 코드3.md">4.11 데코레이터 패턴 - 예제 코드3</a>
1) 예제 코드 : 실행 시간을 측정하면서, 응답값을 꾸며주는 데코레이터
2) 실행 : 프록시가 다른 프록시를 호출하는 연쇄가 가능

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.12 프록시 패턴과 데코레이터 패턴 정리.md">4.12 프록시 패턴과 데코레이터 패턴 정리</a>
1) GOF 데코레이터 패턴
2) 프록시 패턴 vs 데코레이터 패턴 : '의도'가 중요

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.13 인터페이스 기반 프록시 - 적용.md">4.13 인터페이스 기반 프록시 - 적용</a>
1) V1 기존 클래스 의존관계
2) V1에 인터페이스 기반 프록시 적용
3) V1에 인터페이스 기반 프록시 적용 - 의존관계 상세 분석
4) 실행 및 로그 확인 : 원본 코드를 손대지 않고 로그 기능 추가 성공
5) 정리 : 요구사항은 만족하긴 하는데, 프록시를 매번 새로 만드는게 귀찮다.

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.14 구체 클래스 기반 프록시 - 예제1.md">4.14 구체 클래스 기반 프록시 - 예제1</a>
1) 예제 코드 : 구체 클래스 기반 프록시 적용 전

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.15 구체 클래스 기반 프록시 - 예제2.md">4.15 구체 클래스 기반 프록시 - 예제2</a>
1) 구체 클래스 기반 프록시 도입 원리 : 상속과 다형성
2) 예제 코드 : 구체 클래스 기반 프록시 도입
3) 실행 및 로그 확인 : 구체 클래스의 경우 상속을 통해 프록시를 만들 수 있다.

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.16 구체 클래스 기반 프록시 - 적용.md">4.16 구체 클래스 기반 프록시 - 적용</a>
1) V2에 구체 클래스 기반 프록시 적용
2) 실행 확인

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.17 인터페이스 기반 프록시와 클래스 기반 프록시.md">4.17 인터페이스 기반 프록시와 클래스 기반 프록시</a>
1) 프록시 도입 : 원본 코드를 변경하지 않고 부가기능 적용
2) 인터페이스 기반 프록시 vs 구체 클래스 기반 프록시
3) 현재 방식의 한계 : 부가기능을 적용하기 위해 모두 프록시를 모두 만들어야한다.

---

## Chapter 05. 동적 프록시 기술

### <a href="Chapter 05. 동적 프록시 기술/5.1 리플렉션.md">5.1 리플렉션</a>
1) 요구사항 : 프록시를 동적으로 만들어내기
2) 예제 코드 : 공통 로직 사이에 일부분의 호출 메서드만 다른 상황
3) `reflection1()` : 리플렉션 적용
4) `reflection2()` : 전체 흐름을 공통화
5) 리플렉션 사용 시 주의점

### <a href="Chapter 05. 동적 프록시 기술/5.2 JDK 동적 프록시 - 소개.md">5.2 JDK 동적 프록시 - 소개</a>
1) JDK 동적 프록시 기술 : 인터페이스 기반
2) 기본 예제 코드

### <a href="Chapter 05. 동적 프록시 기술/5.3 JDK 동적 프록시 - 예제 코드.md">5.3 JDK 동적 프록시 - 예제 코드</a>
1) JDK 동적 프록시 기술 - `InvocationHandler` 인터페이스
2) 실습 코드 : `TimeInvocationHandler`
3) JDK 동적 프록시 기술 사용법 : `JdkDynamicProxyTest`
4) JDK 동적 프록시의 실행 흐름
5) 공통 로직을 한 곳에서 집중적으로 관리할 수 있다. (SRP)
6) 동적 프록시 도입 전 vs 동적 프록시 도입 후

### <a href="Chapter 05. 동적 프록시 기술/5.4 JDK 동적 프록시 - 적용1.md">5.4 JDK 동적 프록시 - 적용1</a>
1) JDK 동적 프록시를 애플리케이션에 적용 (인터페이스 기반)
2) 의존관계 비교
3) 남은 문제 : 프록시의 부가기능을 사용하고 싶지 않을 때는?

### <a href="Chapter 05. 동적 프록시 기술/5.5 JDK 동적 프록시 - 적용2.md">5.5 JDK 동적 프록시 - 적용2</a>
1) (실습) 메서드 이름 필터 기능 추가
2) JDK 동적 프록시 기술의 한계점 : 인터페이스가 필수

### <a href="Chapter 05. 동적 프록시 기술/5.6 CGLIB - 소개.md">5.6 CGLIB - 소개</a>
1) CGLIB : 구체 클래스만으로 동적 프록시 생성 가능
2) 공통 예제 코드

### <a href="Chapter 05. 동적 프록시 기술/5.7 CGLIB - 예제 코드.md">5.7 CGLIB - 예제 코드</a>
1) CGLIB 동적 기술 - `MethodInterceptor` 인터페이스
2) 실습 코드 : `TimeMethodInterceptor`
3) CGLIB 동적 프록시 기술 사용법 : `CglibTest`
4) CGLIB 기술 적용 후 의존관계
5) CGLIB 기술 제약사항 : 기본생성자 필수, 클래스/메서드 final 키워드 금지
6) 남은 문제 : 인터페이스/구체클래스 동적 프록시 공통화, 필터링 기능

---

## Chapter 06. 스프링이 지원하는 프록시

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.01 프록시 팩토리 - 소개.md">6.01 프록시 팩토리 - 소개</a>
1) 기존 방식의 문제점
2) `ProxyFactory` : JDK 동적 프록시, CGLIB 동적 프록시를 상황에 맞게 동적으로 생성
3) `Advice` : 프록시에 적용할 부가기능 정의
4) `Pointcut` : 특정 조건이 맞을 때만 프록시 적용

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.02 프록시 팩토리 - 예제 코드1.md">6.02 프록시 팩토리 - 예제 코드1</a>
1) `Advice` : MethodInterceptor(스프링이 제공하는 Advice)
2) (실습) `Advice` 만들기 : `TimeAdvice`
3) `ProxyFactory` 사용법 : ProxyFactoryTest
4) `AopUtils.isXXX()` : 프록시 팩토리를 통한 프록시 적용 확인

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.03 프록시 팩토리 - 예제 코드2.md">6.03 프록시 팩토리 - 예제 코드2</a>
1) 구체 클래스만 있으면 프록시 팩토리는 CGLIB 프록시를 생성한다.
2) `proxyTargetClass` 옵션 : `target`의 클래스 기반 프록시 생성 -> 무조건 CGLIB 적용
3) 프록시 팩토리의 기술 선택 방법
4) 프록시 팩토리 덕에, 특정 기술에 종속적이지 않은 방식으로 동적 프록시를 생성할 수 있다.
5) 스프링 부트는 AOP 적용시 `proxyTargetClass=true`를 기본적으로 설정한다.

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.04 포인트컷, 어드바이스, 어드바이저 - 소개.md">6.04 포인트컷, 어드바이스, 어드바이저 - 소개</a>
1) 포인트컷(Pointcut) : 어디에?
2) 어드바이스(Advice) : 어떤 로직을?
3) 어드바이저(Advisor) : 어디에(Pointcut) + 어떤 로직을(Advice)?
4) 포인트컷, 어드바이스, 어드바이저 전체 구조

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.05 예제 코드1 - 어드바이저.md">6.05 예제 코드1 - 어드바이저</a>
1) 프록시 팩토리 - 어드바이저 관계
2) 어드바이저를 지정하는 방법 - `AdvisorTest`
3) `addAdivce()`는 항상 통과되는 어드바이저를 내부적으로 지정하는 편의 메서드다.

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.06 예제 코드2 - 직접 만든 포인트컷.md">6.06 예제 코드2 - 직접 만든 포인트컷</a>
1) 포인트컷 관련 인터페이스
2) 직접 포인트컷 만들기
3) 포인트컷 적용 시 프록시 로직 흐름

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.07 예제 코드3 - 스프링이 제공하는 포인트컷.md">6.07 예제 코드3 - 스프링이 제공하는 포인트컷</a>
1) (실습) 스프링이 제공하는 `NameMatchMethodPointcut` 적용해보기
2) 스프링이 제공하는 포인트컷들
3) 가장 중요한 것은 `AspectJExpressionPointcut`

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.08 예제 코드4 - 여러 어드바이저 함께 적용.md">6.08 예제 코드4 - 여러 어드바이저 함께 적용</a>
1) 여러 프록시를 생성하는 방식 (bad)
2) 하나의 프록시에 여러 어드바이저 등록(ProxyFactory, Spring AOP)
3) 스프링 AOP : 하나의 프록시에 여러 어드바이저가 적용된다.

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.09 프록시 팩토리 - 적용1.md">6.09 프록시 팩토리 - 적용1</a>
1) ProxyFactory를 통해 인터페이스 기반 프록시를 애플리케이션에 적용

### <a href="Chapter 06. 스프링이 지원하는 프록시/6.10 프록시 팩토리 - 적용2.md">6.10 프록시 팩토리 - 적용2</a>
1) ProxyFactory를 통해 구체 클래스 기반 프록시를 애플리케이션에 적용
2) 의의 : 프록시 생성의 추상화, 부가기능과 필터링 로직 역할 분리
3) 남은 문제 : 결국 수동으로 프록시를 생성해야하고 컴포넌트 스캔 사용 시 적용이 힘들다.

---

## Chapter 07. 빈 후처리기

### <a href="Chapter 07. 빈 후처리기/7.1 빈 후처리기 - 소개.md">7.1 빈 후처리기 - 소개</a>
1) 일반적인 스프링 빈 등록 : 생성한 그대로 등록
2) 빈 후처리기(BeanPostProcessor) : 등록 직전 조작/바꿔치기

### <a href="Chapter 07. 빈 후처리기/7.2 빈 후처리기 - 예제 코드1.md">7.2 빈 후처리기 - 예제 코드1</a>
1) 일반적인 빈 등록 과정 - BasicTest

### <a href="Chapter 07. 빈 후처리기/7.3 빈 후처리기 - 예제 코드2.md">7.3 빈 후처리기 - 예제 코드2</a>
1) BeanPostProcessor 인터페이스 - 스프링 제공
2) 빈 후처리기 적용 예제 - BeanPostProcessorTest
3) `@PostConstruct` : 스프링도 자체적으로 빈 후처리기를 등록한다.
4) 빈 후처리기 : 빈을 조작하고 변경할 수 있는 후킹 포인트

### <a href="Chapter 07. 빈 후처리기/7.4 빈 후처리기 - 적용.md">7.4 빈 후처리기 - 적용</a>
1) 애플리케이션에 빈 후처리기 적용
2) 애플리케이션 로딩 로그 - 컴포넌트 스캔에도 프록시가 적용됐다.
3) 모든 빈들에 프록시가 적용 되지 않도록 필터링 로직이 필요하다.
4) 실행 확인

### <a href="Chapter 07. 빈 후처리기/7.5 빈 후처리기 - 정리.md">7.5 빈 후처리기 - 정리</a>
1) 기존의 문제들
2) 해결된 문제들
3) 개선의 여지 : 포인트 컷을 이용해 필터링할 수 없을까?
4) 한 걸음 더 : 스프링의 자동 프록시 생성 빈 후처리기

### <a href="Chapter 07. 빈 후처리기/7.6 스프링이 제공하는 빈 후처리기1.md">7.6 스프링이 제공하는 빈 후처리기1</a>
1) `build.gradle`에 AOP 관련 라이브러리 추가
2) 자동 프록시 생성기 - AutoProxyCreator
3) 자동 프록시 생성기의 작동 흐름
4) 생성된 프록시 : 자신에게 적용된 Advisor들과 target을 알고 있다.
5) 애플리케이션에 자동 프록시 생성 빈 후처리기 적용
6) 포인트 컷의 2가지 사용처

### <a href="Chapter 07. 빈 후처리기/7.7 스프링이 제공하는 빈 후처리기2.md">7.7 스프링이 제공하는 빈 후처리기2</a>
1) 요구사항 : 정밀한 포인트컷 필요
2) AspectJ 표현식 포인트컷 수동 적용1 - package 기준
3) AspectJ 표현식 포인트컷 수동 적용2 - package + 특정 메서드명 제외

### <a href="Chapter 07. 빈 후처리기/7.8 하나의 프록시, 여러 Advisor 적용.md">7.8 하나의 프록시, 여러 Advisor 적용</a>
1) 여러 어드바이저가 적용 대상이더라도, 프록시는 단 하나만 생성된다.
2) 자동 프록시 생성기 상황별 정리
3) 의의 : 어드바이저만 스프링 빈으로 등록하면 된다.

---

## Chapter 08. @Aspect AOP
### <a href="Chapter 08. @Aspect AOP/8.1 @Aspect 프록시 - 적용.md">8.1 @Aspect 프록시 - 적용</a>
1) `@Aspect` : 어드바이저 모음, 모듈
2) 애플리케이션에 `@Aspect` 프록시 적용 : `LogTraceAspect`

### <a href="Chapter 08. @Aspect AOP/8.2 @Aspect 프록시 - 설명.md">8.2 @Aspect 프록시 - 설명</a>
1) 자동 프록시 생성기 : 어드바이저 기반 프록시 생성 + `@Aspect`로 어드바이저 변환 및 저장
2) `@Aspect` 를 어드바이저로 변환해서 저장하는 과정
3) 어드바이저를 기반으로 프록시를 생성하는 과정

---

## Chapter 09. 스프링 AOP 개념

### <a href="Chapter 09. 스프링 AOP 개념/9.1 AOP 소개 - 핵심 기능과 부가 기능.md">9.1 AOP 소개 - 핵심 기능과 부가 기능</a>
1) 핵심 기능, 부가 기능
2) 횡단 관심사 : 같은 부가기능이 여러 곳에서 동일하게 요구되고, 사용됨
3) 부가 기능 적용 문제 : 중복 코드가 발생하고, 유지보수가 힘들다.

### <a href="Chapter 09. 스프링 AOP 개념/9.2 AOP 소개 - 애스펙트.md">9.2 AOP 소개 - 애스펙트</a>
1) 애스펙트 : 부가기능 + 부가기능 적용 위치 선택 기능을 모듈화
2) 관점 지향 프로그래밍(Aspect-Oriented Programming)
3) AspectJ 프레임워크와 스프링 AOP


### <a href="Chapter 09. 스프링 AOP 개념/9.3 AOP 적용 방식.md">9.3 AOP 적용 방식</a>
1) AOP 적용 방식1 - 컴파일 시점
2) AOP 적용 방식2 - 클래스 로딩 시점 (로드 타임 위빙)
3) AOP 적용 방식3 - 런타임 시점(프록시)
4) AOP 적용 방식 비교
5) 조인 포인트 : AOP 적용 위치
6) 선택 : AspectJ vs Spring AOP

### <a href="Chapter 09. 스프링 AOP 개념/9.4 AOP 용어 정리.md">9.4 AOP 용어 정리</a>
1) 조인 포인트(Join point) : AOP를 적용할 수 있는 모든 지점
2) 포인트컷(Pointcut) : 어드바이스가 적용될 위치를 지정
3) 타겟(Target) : 어드바이스를 받는 객체
4) 어드바이스(Advice) : 부가 기능
5) 애스펙트(Aspect) : 어드바이스 + 포인트컷 모듈화
6) 어드바이저(Advisor) : 어드바이스 1 + 포인트 컷 1
7) 위빙(Weaving) : 포인트컷으로 결정한 타켓의 조인 포인트에 어드바이스를 적용하는 것
8) AOP 프록시 : AOP를 구현하기 위해 만든 프록시 객체

---

## Chapter 10. 스프링 AOP 구현

### <a href="Chapter 10. 스프링 AOP 구현/10.1 프로젝트 생성.md">10.1 프로젝트 생성</a>
1) 프로젝트 생성
2) `build.gradle`에 라이브러리 추가
3) IDE 설정
4) 실행 확인

### <a href="Chapter 10. 스프링 AOP 구현/10.2 예제 프로젝트 만들기.md">10.2 예제 프로젝트 만들기</a>
1) AOP를 적용할 예제 프로젝트 생성

### <a href="Chapter 10. 스프링 AOP 구현/10.3 스프링 AOP 구현1 - 시작.md">10.3 스프링 AOP 구현1 - 시작</a>
1) `@Aspect`를 이용한 AOP 구현 - 기본
2) 애스펙트를 스프링 빈으로 개발자가 등록해야한다.
3) 실행 및 로그 확인

### <a href="Chapter 10. 스프링 AOP 구현/10.4 스프링 AOP 구현2 - 포인트컷 분리.md">10.4 스프링 AOP 구현2 - 포인트컷 분리</a>
1) `@Pointcut` : 포인트컷 분리

### <a href="Chapter 10. 스프링 AOP 구현/10.5 스프링 AOP 구현3 - 어드바이스 추가.md">10.5 스프링 AOP 구현3 - 어드바이스 추가</a>
1) 어드바이스 추가 : 애스펙트 메서드를 더 만들면 됨
2) 한계 : 어드바이스 적용 순서를 지정할 수 없을까?

### <a href="Chapter 10. 스프링 AOP 구현/10.6 스프링 AOP 구현4 - 포인트컷 참조.md">10.6 스프링 AOP 구현4 - 포인트컷 참조</a>
1) 포인트컷들을 외부 클래스에 분리해 모아두기

### <a href="Chapter 10. 스프링 AOP 구현/10.7 스프링 AOP 구현5 - 어드바이스 순서.md">10.7 스프링 AOP 구현5 - 어드바이스 순서</a>
1) `@Order(...)` : 클래스 단위 어드바이스 순서 지정
2) (실습) 애플리케이션의 어드바이스들에 순서 지정

### <a href="Chapter 10. 스프링 AOP 구현/10.8 스프링 AOP 구현6 - 어드바이스 종류.md">10.8 스프링 AOP 구현6 - 어드바이스 종류</a>
작성 중

---

## Chapter 11. 스프링 AOP - 포인트컷
### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.01 포인트컷 지시자.md">11.01 포인트컷 지시자</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.02 예제 만들기.md">11.02 예제 만들기</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.03 execution - 1.md">11.03 execution - 1</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.04 execution - 2.md">11.04 execution - 2</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.05 within.md">11.05 within</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.06 args.md">11.06 args</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.07 @target, @within.md">11.07 @target, @within</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.08 @annotation, @args.md">11.08 @annotation, @args</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.09 bean.md">11.09 bean</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.10 매개변수 전달.md">11.10 매개변수 전달</a>
작성 중

### <a href="Chapter 11. 스프링 AOP - 포인트컷/11.11 this, target.md">11.11 this, target</a>
작성 중

---

## Chapter 12. 스프링 AOP - 실전 예제

### <a href="Chapter 12. 스프링 AOP - 실전 예제/12.1 예제 만들기.md">12.1 예제 만들기</a>
작성 중

### <a href="Chapter 12. 스프링 AOP - 실전 예제/12.2 로그 출력 AOP.md">12.2 로그 출력 AOP</a>
작성 중

### <a href="Chapter 12. 스프링 AOP - 실전 예제/12.3 재시도 AOP.md">12.3 재시도 AOP</a>
작성 중

---

## Chapter 13. 스프링 AOP - 실무 주의사항

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.1 프록시와 내부 호출 - 문제.md">13.1 프록시와 내부 호출 - 문제</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.2 프록시와 내부 호출 - 대안1 자기 자신 주입.md">13.2 프록시와 내부 호출 - 대안1 자기 자신 주입</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.3 프록시와 내부 호출 - 대안2 지연 조회.md">13.3 프록시와 내부 호출 - 대안2 지연 조회</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.4 프록시와 내부 호출 - 대안3 구조 변경.md">13.4 프록시와 내부 호출 - 대안3 구조 변경</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.5 프록시 기술과 한계 - 타입 캐스팅.md">13.5 프록시 기술과 한계 - 타입 캐스팅</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.6 프록시 기술과 한계 - 의존관계 주입.md">13.6 프록시 기술과 한계 - 의존관계 주입</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.7 프록시 기술과 한계 - CGLIB.md">13.7 프록시 기술과 한계 - CGLIB</a>
작성 중

### <a href="Chapter 13. 스프링 AOP - 실무 주의사항/13.8 프록시 기술과 한계 - 스프링의 해결책.md">13.8 프록시 기술과 한계 - 스프링의 해결책</a>
작성 중

---
