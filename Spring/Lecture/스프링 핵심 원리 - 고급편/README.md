
# 스프링 핵심 원리 - 고급편

---

## Chapter 01. 예제 만들기
### <a href="Chapter 01. 예제 만들기/1.1 프로젝트 생성.md">1.1 프로젝트 생성</a>
1) 프로젝트 생성
2) IDE 설정
3) 실행 확인

### <a href="Chapter 01. 예제 만들기/1.2 예제 프로젝트 만들기 - V0.md">1.2 예제 프로젝트 만들기 - V0</a>
1) `OrderRepositoryV0` : 리포지토리
2) `OrderServiceV0` : 서비스
3) `OrderControllerV0` : 컨트롤러
4) 실행 확인

### <a href="Chapter 01. 예제 만들기/1.3 로그 추적기 - 요구사항 분석.md">1.3 로그 추적기 - 요구사항 분석</a>
1) 문제 상황 : 모든 로직, 예외 발생 상황에 로그 작성
2) 세부 요구사항 및 예시

### <a href="Chapter 01. 예제 만들기/1.4 로그 추적기 V1 - 프로토타입 개발.md">1.4 로그 추적기 V1 - 프로토타입 개발</a>
1) TraceId - 트랜잭션의 Id, 깊이
2) TraceStatus : 로그의 상태 정보
3) HelloTraceV1 : 프로토타입 로그 추적기
4) HelloTraceV1Test : 테스트

### <a href="Chapter 01. 예제 만들기/1.5 로그 추적기 V1 - 적용.md">1.5 로그 추적기 V1 - 적용</a>
1) `v0` -> `v1`
2) 각 계층마다 로그 추적기 의존관계 추가
3) 각 메서드 시작/종료 시점에 로그 추적기 코드 실행 - V1 적용
4) 실행 및 로그 확인
5) 남은 문제 : 메서드 깊이 표현, HTTP 요청 구분

### <a href="Chapter 01. 예제 만들기/1.6 로그 추적기 V2 - 파라미터로 동기화 개발.md">1.6 로그 추적기 V2 - 파라미터로 동기화 개발</a>
1) `HelloTraceV2.beginSync` : TraceId를 파라미터로 전달받아 동기화
2) HelloTraceV2Test

### <a href="Chapter 01. 예제 만들기/1.7 로그 추적기 V2 - 적용.md">1.7 로그 추적기 V2 - 적용</a>
1) `v1` -> `v2` 복사
2) V2 적용하기 : 메서드마다 traceId 파라미터 추가
3) 실행 및 로그 분석
4) 파라미터를 수정하지 않고 TraceId를 동기화할 방법이 필요

---

## Chapter 02. 스레드 로컬 - ThreadLocal

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.1 필드 동기화 - 개발.md">2.1 필드 동기화 - 개발</a>
1) 아이디어 : 로그 추적기의 필드에서 `TracaeId`를 공유하고, 동기화
2) `LogTrace` 인터페이스
3) `FieldLogTrace` : 파라미터를 넘기지 않고 필드에서 TraceId 동기화
4) `FieldLogTrace` 사용 흐름
5) `FieldLogTraceTest` : 필드 로그 추적기 테스트

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.2 필드 동기화 - 적용.md">2.2 필드 동기화 - 적용</a>
1) `LogTraceConfig` : `LogTrace`를 수동 빈 등록할 `Configuration`
2) `v2` -> `v3` 코드 수정
3) 실행 및 로그 분석

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.3 필드 동기화 - 동시성 문제.md">2.3 필드 동기화 - 동시성 문제</a>
1) 필드 동기화의 심각한 문제 확인 : 여러 요청이 동시에 들어올 때?
2) 기대하는 결과 : 각 요청 스레드마다 올바른 로그 출력
3) 실제 결과 - 여러 요청(스레드)이 같은 TraceId를 공유하고, 로그가 꼬임
4) 동시성 문제 : 싱글톤 인스턴스의 공유 변수 동시 접근

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.4 동시성 문제 - 예제 코드.md">2.4 동시성 문제 - 예제 코드</a>
1) `FieldService` : `nameStore`에 `name`을 저장하고 조회하는 로직
2) (실습) 동시성 문제 없는 코드
3) (실습) 동시성 문제 발생 코드
4) 동시성 문제 : 여러 스레드가 같은 인스턴스, static 필드를 변경 후 조회하면서 발생

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.5 ThreadLocal - 소개.md">2.5 ThreadLocal - 소개</a>
1) 기존 : 일반적인 변수 필드에 여러 스레드가 데이터를 저장하는 방식
2) 스레드 로컬 : 각 스레드마다 할당된 특별한 저장소
3) 스레드 로컬 : 흐름

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.6 ThreadLocal - 예제 코드.md">2.6 ThreadLocal - 예제 코드</a>
1) (실습) `ThreadLocalService` : ThreadLocal에 `name`을 저장하고 조회하는 로직
2) ThreadLocal 사용법
3) ThreadLocalServiceTest : 동시성 문제 해결

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.7 스레드 로컬 동기화 - 개발.md">2.7 스레드 로컬 동기화 - 개발</a>
1) `ThreadLocalLogTrace` : 로그 추적기에 스레드 로컬 적용
2) `ThreadLocal`을 모두 사용한 후 반드시 remove를 호출해서 저장 값을 제거해야한다.
3) `ThreadLocalLogTraceTest` : 테스트 실행

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.8 스레드 로컬 동기화 - 적용.md">2.8 스레드 로컬 동기화 - 적용</a>
1) 로그 추적기 구현체 빈을 `ThreadLocalLogTrace`로 변경
2) 실행 확인
3) 동시성 문제 해결 확인

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.9 스레드 로컬 - 주의사항.md">2.9 스레드 로컬 - 주의사항</a>
1) 스레드 로컬 사용 후 저장 값 제거를 안 하면, 사용자 정보 유출 위험이 있다.
2) 스레드 로컬 사용 후 반드시 `remove`를 호출 하자.

---

## Chapter 03. 템플릿 메서드 패턴과 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.01 템플릿 메서드 패턴 - 시작.md">3.01 템플릿 메서드 패턴 - 시작</a>
1) 로그 추적기를 도입하니, 핵심기능에 부가기능이 잔뜩 붙어서 코드 복잡도가 많이 증가됐다.
2) 핵심 기능, 부가 기능
3) 동일한 패턴이 존재하는데 이를 공통화 할 방법이 없을까?
4) 변하는 것과 변하지 않는 것을 분리해야한다.
5) 해결책 : 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.02 템플릿 메서드 패턴 - 예제1.md">3.02 템플릿 메서드 패턴 - 예제1</a>
1) `templateMethodV0()` : 비즈니스 로직만 다르고 나머지는 모두 같은 두 코드
2) 변하는 부분, 변하지 않는 부분

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.03 템플릿 메서드 패턴 - 예제2.md">3.03 템플릿 메서드 패턴 - 예제2</a>
1) 템플릿 메서드 패턴(Template Method Pattern)
2) 추상 클래스를 통해 전체 틀을 정해두고, 변하는 부분을 하위 클래스에서 구현한다.
3) `templateMethodV1` : 템플릿 메서드 패턴 적용
4) 템플릿 메서드 패턴의 인스턴스 호출 과정

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.04 템플릿 메서드 패턴 - 예제3.md">3.04 템플릿 메서드 패턴 - 예제3</a>
1) 익명 내부 클래스 사용하기
2) `templateMethodV2()` - 템플릿 메서드 패턴에서 익명 내부 클래스를 사용

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.05 템플릿 메서드 패턴 - 적용1.md">3.05 템플릿 메서드 패턴 - 적용1</a>
1) `AbstractTemplate` : 로그 추적 템플릿
2) `v3` -> `v4` 복사
3) 애플리케이션 수정 : 템플릿 메서드 패턴 적용
4) 실행 확인

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.06 템플릿 메서드 패턴 - 적용2.md">3.06 템플릿 메서드 패턴 - 적용2</a>
1) 지금까지 작성한 코드 비교
2) 좋은 설계 : 변경에 쉽게 대처할 수 있는 코드
3) 템플릿 메서드 패턴과 단일 책임 원칙(SRP)

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.07 템플릿 메서드 패턴 - 정의.md">3.07 템플릿 메서드 패턴 - 정의</a>
1) 템플릿 메서드 패턴의 정의
2) 템플릿 메서드 패턴의 문제점 : 상속과 강한 결합
3) 개선안 : 전략 패턴, 템플릿 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.08 전략 패턴 - 시작.md">3.08 전략 패턴 - 시작</a>
1) 예제 생성 : `ContextV1Test`

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.09 전략 패턴 - 예제1.md">3.09 전략 패턴 - 예제1</a>
1) 템플릿 메서드 패턴 vs 전략 패턴
2) `ContextV1`, `Strategy` : 전략 패턴 예제 코드
3) `strategyV1()` : 전략 패턴 적용 예제 코드 실행
4) 전략 패턴 실행 흐름
5) 스프링과 전략 패턴의 공통점

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.10 전략 패턴 - 예제2.md">3.10 전략 패턴 - 예제2</a>
1) `strategyV2()` : 전략 패턴에 익명 내부 클래스 사용
2) `strategyV3()` : 전략 익명 내부 클래스를 생성과 동시에 인자로 전달
3) `strategyV4()` : 전략을 람다로 구현해서 전달
4) 일반적인 전략 패턴 : 선 조립 후 실행
5) 일반적인 전략 패턴의 단점 : 조립 이후 전략 변경이 번거롭다.

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.11 전략 패턴 - 예제3.md">3.11 전략 패턴 - 예제3</a>
1) `ContextV2` : 전략을 파라미터로 전달받는 방식
2) `ContextV2Test.strategyV1()` : 메서드 파라미터로 전략 전달
3) 전략 패턴 - 파라미터로 전략 전달 시 실행 흐름
4) `ContextV2Test.strategyV2()` : 메서드 파라미터로 전략 전달(익명 내부 클래스)
5) `ContextV2Test.strategyV2()` : 메서드 파라미터로 전략 전달(람다)
6) 필드에 전략을 전달하기 vs 메서드 파라미터로 전략을 전달하기
7) 템플릿의 작은 변하는 부분에 사용할 다른 코드 조각을 넘기는 것

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.12 템플릿 콜백 패턴 - 시작.md">3.12 템플릿 콜백 패턴 - 시작</a>
1) 콜백(Callback)
2) 템플릿 콜백 패턴(Template Callback Pattern)

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.13 템플릿 콜백 패턴 - 예제.md">3.13 템플릿 콜백 패턴 - 예제</a>
1) 앞서 구현한 파라미터 전략 전달 방식과 구조적으로 동일하다.
2) `Callback` : 템플릿의 메서드 파라미터로 전달되는 코드 조각(전략)
3) `TimeLogTemplate` : 템플릿
4) `TemplateCallbackTest` : 템플릿 콜백 패턴 적용 테스트

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.14 템플릿 콜백 패턴 - 적용.md">3.14 템플릿 콜백 패턴 - 적용</a>
1) `TraceCallback` : 로그 추적 템플릿에 전달할 콜백
2) `TraceTemplate` : 로그 추적 템플릿
3) `v4` -> `v5` 복사
4) 각 계층에서 `TraceTemplate`를 의존하게 변경
5) 애플리케이션에 템플릿 콜백 패턴 적용
6) 실행 확인
7) 최적화를 통해 변하는 코드, 변하지 않는 코드를 분리하는데 성공했다.
8) 한계 : 결국 원본 코드를 수정해야한다.

---

## Chapter 04. 프록시 패턴과 데코레이터 패턴
### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.01 프로젝트 생성.md">4.01 프로젝트 생성</a>
1) 프로젝트 설정

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.02 예제 프로젝트 만들기 v1.md">4.02 예제 프로젝트 만들기 v1</a>
1) 앞으로 만들 예제들 - 개요
2) `v1` - 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.03 예제 프로젝트 만들기 v2.md">4.03 예제 프로젝트 만들기 v2</a>
1) `v2` - 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.04 예제 프로젝트 만들기 v3.md">4.04 예제 프로젝트 만들기 v3</a>
1) `v3` - 컴포넌트 스캔으로 스프링 빈 자동 등록

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.05 요구사항 추가.md">4.05 요구사항 추가</a>
1) 기존 요구사항
2) 기존 방식의 한계 : 핵심 기능 코드를 건들 수밖에 없음
3) 요구사항 추가 : 원본 코드를 수정하지 않고 로그 추적기 적용
4) 해결책 : 프록시 개념 이해, 프록시 패턴/데코레이터 패턴 이해

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.06 프록시, 프록시 패턴, 데코레이터 패턴 - 소개.md">4.06 프록시, 프록시 패턴, 데코레이터 패턴 - 소개</a>
1) 클라이언트와 서버 : 요청하는 측, 요청을 처리하는 측
2) 직접 호출, 프록시를 통한 간접 호출
3) 프록시 체인 : 프록시는 여러 개를 둘 수 있다
4) 프록시는 서버와 같은 인터페이스를 구현하고, 대체하여 주입된다.
5) 프록시의 주요기능 : 접근제어, 부가 기능 추가
6) 프록시, 프록시 패턴, 데코레이터 패턴

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.07 프록시 패턴 - 예제 코드1.md">4.07 프록시 패턴 - 예제 코드1</a>
1) 테스트 환경 준비
2) 예제 코드 : 프록시 패턴 적용 전
3) 실행 및 로그 분석 : 동일한 작업을 세번 반복

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.08 프록시 패턴 - 예제 코드2.md">4.08 프록시 패턴 - 예제 코드2</a>
1) 예제 코드 : 프록시 패턴 적용 후
2) 실행 및 로그 분석 : 프록시의 캐싱을 통한 성능 개선
3) 정리 : 클라이언트와 서버의 코드 변경 없이, 프록시를 도입해서 접근 제어

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.09 데코레이터 패턴 - 예제 코드1.md">4.09 데코레이터 패턴 - 예제 코드1</a>
1) 예제 코드 : 데코레이터 패턴 적용 전
2) 실행 확인 : RealComponent가 반환한 원본 값 그대로 받음

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.10 데코레이터 패턴 - 예제 코드2.md">4.10 데코레이터 패턴 - 예제 코드2</a>
1) 데코레이터 패턴 : 프록시를 통해 부가기능 추가
2) 예제 코드 : 응답 값을 꾸며주는 데코레이터
3) 실행 : 데코레이터를 통해 부가기능을 추가

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.11 데코레이터 패턴 - 예제 코드3.md">4.11 데코레이터 패턴 - 예제 코드3</a>
1) 예제 코드 : 실행 시간을 측정하면서, 응답값을 꾸며주는 데코레이터
2) 실행 : 프록시가 다른 프록시를 호출하는 연쇄가 가능

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.12 프록시 패턴과 데코레이터 패턴 정리.md">4.12 프록시 패턴과 데코레이터 패턴 정리</a>
1) GOF 데코레이터 패턴
2) 프록시 패턴 vs 데코레이터 패턴 : '의도'가 중요

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.13 인터페이스 기반 프록시 - 적용.md">4.13 인터페이스 기반 프록시 - 적용</a>
1) V1 기존 클래스 의존관계
2) V1에 인터페이스 기반 프록시 적용
3) V1에 인터페이스 기반 프록시 적용 - 의존관계 상세 분석
4) 실행 및 로그 확인 : 원본 코드를 손대지 않고 로그 기능 추가 성공
5) 정리 : 요구사항은 만족하긴 하는데, 프록시를 매번 새로 만드는게 귀찮다.

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.14 구체 클래스 기반 프록시 - 예제1.md">4.14 구체 클래스 기반 프록시 - 예제1</a>
1) 예제 코드 : 구체 클래스 기반 프록시 적용 전

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.15 구체 클래스 기반 프록시 - 예제2.md">4.15 구체 클래스 기반 프록시 - 예제2</a>
1) 구체 클래스 기반 프록시 도입 원리 : 상속과 다형성
2) 예제 코드 : 구체 클래스 기반 프록시 도입
3) 실행 및 로그 확인 : 구체 클래스의 경우 상속을 통해 프록시를 만들 수 있다.

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.16 구체 클래스 기반 프록시 - 적용.md">4.16 구체 클래스 기반 프록시 - 적용</a>
작성중

### <a href="Chapter 04. 프록시 패턴과 데코레이터 패턴/4.17 인터페이스 기반 프록시와 클래스 기반 프록시.md">4.17 인터페이스 기반 프록시와 클래스 기반 프록시</a>
작성중

---

## Chapter 05. 동적 프록시 기술
### 5.1 리플렉션
### 5.2 JDK 동적 프록시 - 소개
### 5.3 JDK 동적 프록시 - 예제 코드
### 5.4 JDK 동적 프록시 - 적용1
### 5.5 JDK 동적 프록시 - 적용2
### 5.6 CGLIB - 소개
### 5.7 CGLIB - 예제 코드

---

## Chapter 06. 스프링이 지원하는 프록시
### 6.01 프록시 팩토리 - 소개
### 6.02 프록시 팩토리 - 예제 코드1
### 6.03 프록시 팩토리 - 예제 코드2
### 6.04 포인트컷, 어드바이스, 어드바이저 - 소개
### 6.05 예제 코드1 - 어드바이저
### 6.06 예제 코드2 - 직접 만든 포인트컷
### 6.07 예제 코드3 - 스프링이 제공하는 포인트컷
### 6.08 예제 코드4 - 여러 어드바이저 함께 적용
### 6.09 프록시 팩토리 - 적용1
### 6.10 프록시 팩토리 - 적용2

---

## Chapter 07. 빈 후처리기
### 7.1 빈 후처리기 - 소개
### 7.2 빈 후처리기 - 예제 코드1
### 7.3 빈 후처리기 - 예제 코드2
### 7.4 빈 후처리기 - 적용
### 7.5 빈 후처리기 - 정리
### 7.6 스프링이 제공하는 빈 후처리기1
### 7.7 스프링이 제공하는 빈 후처리기2
### 7.8 하나의 프록시, 여러 Advisor 적용

---

## Chapter 08. @Aspect AOP
### 8.1 @Aspect 프록시 - 적용
### 8.2 @Aspect 프록시 - 설명

---

## Chapter 09. 스프링 AOP 개념
### 9.1 AOP 소개 - 핵심 기능과 부가 기능
### 9.2 AOP 소개 - 애스펙트
### 9.3 AOP 적용 방식
### 9.4 AOP 용어 정리

---

## Chapter 10. 스프링 AOP 구현
### 10.1 프로젝트 생성
### 10.2 예제 프로젝트 만들기
### 10.3 스프링 AOP 구현1 - 시작
### 10.4 스프링 AOP 구현2 - 포인트컷 분리
### 10.5 스프링 AOP 구현3 - 어드바이스 추가
### 10.6 스프링 AOP 구현4 - 포인트컷 참조
### 10.7 스프링 AOP 구현5 - 어드바이스 순서
### 10.8 스프링 AOP 구현6 - 어드바이스 종류

---

## Chapter 11. 스프링 AOP - 포인트컷
### 11.01 포인트컷 지시자
### 11.02 예제 만들기
### 11.03 execution - 1
### 11.04 execution - 2
### 11.05 within
### 11.06 args
### 11.07 @target, @within
### 11.08 @annotation, @args
### 11.09 bean
### 11.10 매개변수 전달
### 11.11 this, target

---

## Chapter 12. 스프링 AOP - 실전 예제
### 12.1 예제 만들기
### 12.2 로그 출력 AOP
### 12.3 재시도 AOP

---

## Chapter 13. 스프링 AOP - 실무 주의사항
### 13.1 프록시와 내부 호출 - 문제
### 13.2 프록시와 내부 호출 - 대안1 자기 자신 주입
### 13.3 프록시와 내부 호출 - 대안2 지연 조회
### 13.4 프록시와 내부 호출 - 대안3 구조 변경
### 13.5 프록시 기술과 한계 - 타입 캐스팅
### 13.6 프록시 기술과 한계 - 의존관계 주입
### 13.7 프록시 기술과 한계 - CGLIB
### 13.8 프록시 기술과 한계 - 스프링의 해결책

---
