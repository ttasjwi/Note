
# 스프링 핵심 원리 - 고급편

---

## Chapter 01. 예제 만들기
### <a href="Chapter 01. 예제 만들기/1.1 프로젝트 생성.md">1.1 프로젝트 생성</a>
1) 프로젝트 생성
2) IDE 설정
3) 실행 확인

### <a href="Chapter 01. 예제 만들기/1.2 예제 프로젝트 만들기 - V0.md">1.2 예제 프로젝트 만들기 - V0</a>
1) `OrderRepositoryV0` : 리포지토리
2) `OrderServiceV0` : 서비스
3) `OrderControllerV0` : 컨트롤러
4) 실행 확인

### <a href="Chapter 01. 예제 만들기/1.3 로그 추적기 - 요구사항 분석.md">1.3 로그 추적기 - 요구사항 분석</a>
1) 문제 상황 : 모든 로직, 예외 발생 상황에 로그 작성
2) 세부 요구사항 및 예시

### <a href="Chapter 01. 예제 만들기/1.4 로그 추적기 V1 - 프로토타입 개발.md">1.4 로그 추적기 V1 - 프로토타입 개발</a>
1) TraceId - 트랜잭션의 Id, 깊이
2) TraceStatus : 로그의 상태 정보
3) HelloTraceV1 : 프로토타입 로그 추적기
4) HelloTraceV1Test : 테스트

### <a href="Chapter 01. 예제 만들기/1.5 로그 추적기 V1 - 적용.md">1.5 로그 추적기 V1 - 적용</a>
1) `v0` -> `v1`
2) 각 계층마다 로그 추적기 의존관계 추가
3) 각 메서드 시작/종료 시점에 로그 추적기 코드 실행 - V1 적용
4) 실행 및 로그 확인
5) 남은 문제 : 메서드 깊이 표현, HTTP 요청 구분

### <a href="Chapter 01. 예제 만들기/1.6 로그 추적기 V2 - 파라미터로 동기화 개발.md">1.6 로그 추적기 V2 - 파라미터로 동기화 개발</a>
1) `HelloTraceV2.beginSync` : TraceId를 파라미터로 전달받아 동기화
2) HelloTraceV2Test

### <a href="Chapter 01. 예제 만들기/1.7 로그 추적기 V2 - 적용.md">1.7 로그 추적기 V2 - 적용</a>
1) `v1` -> `v2` 복사
2) V2 적용하기 : 메서드마다 traceId 파라미터 추가
3) 실행 및 로그 분석
4) 파라미터를 수정하지 않고 TraceId를 동기화할 방법이 필요

---

## Chapter 02. 스레드 로컬 - ThreadLocal

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.1 필드 동기화 - 개발.md">2.1 필드 동기화 - 개발</a>
1) 아이디어 : 로그 추적기의 필드에서 `TracaeId`를 공유하고, 동기화
2) `LogTrace` 인터페이스
3) `FieldLogTrace` : 파라미터를 넘기지 않고 필드에서 TraceId 동기화
4) `FieldLogTrace` 사용 흐름
5) `FieldLogTraceTest` : 필드 로그 추적기 테스트

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.2 필드 동기화 - 적용.md">2.2 필드 동기화 - 적용</a>
1) `LogTraceConfig` : `LogTrace`를 수동 빈 등록할 `Configuration`
2) `v2` -> `v3` 코드 수정
3) 실행 및 로그 분석

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.3 필드 동기화 - 동시성 문제.md">2.3 필드 동기화 - 동시성 문제</a>
1) 필드 동기화의 심각한 문제 확인 : 여러 요청이 동시에 들어올 때?
2) 기대하는 결과 : 각 요청 스레드마다 올바른 로그 출력
3) 실제 결과 - 여러 요청(스레드)이 같은 TraceId를 공유하고, 로그가 꼬임
4) 동시성 문제 : 싱글톤 인스턴스의 공유 변수 동시 접근

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.4 동시성 문제 - 예제 코드.md">2.4 동시성 문제 - 예제 코드</a>
1) `FieldService` : `nameStore`에 `name`을 저장하고 조회하는 로직
2) (실습) 동시성 문제 없는 코드
3) (실습) 동시성 문제 발생 코드
4) 동시성 문제 : 여러 스레드가 같은 인스턴스, static 필드를 변경 후 조회하면서 발생

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.5 ThreadLocal - 소개.md">2.5 ThreadLocal - 소개</a>
1) 기존 : 일반적인 변수 필드에 여러 스레드가 데이터를 저장하는 방식
2) 스레드 로컬 : 각 스레드마다 할당된 특별한 저장소
3) 스레드 로컬 : 흐름

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.6 ThreadLocal - 예제 코드.md">2.6 ThreadLocal - 예제 코드</a>
1) (실습) `ThreadLocalService` : ThreadLocal에 `name`을 저장하고 조회하는 로직
2) ThreadLocal 사용법
3) ThreadLocalServiceTest : 동시성 문제 해결

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.7 스레드 로컬 동기화 - 개발.md">2.7 스레드 로컬 동기화 - 개발</a>
1) `ThreadLocalLogTrace` : 로그 추적기에 스레드 로컬 적용
2) `ThreadLocal`을 모두 사용한 후 반드시 remove를 호출해서 저장 값을 제거해야한다.
3) `ThreadLocalLogTraceTest` : 테스트 실행

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.8 스레드 로컬 동기화 - 적용.md">2.8 스레드 로컬 동기화 - 적용</a>
1) 로그 추적기 구현체 빈을 `ThreadLocalLogTrace`로 변경
2) 실행 확인
3) 동시성 문제 해결 확인

### <a href="Chapter 02. 스레드 로컬 - ThreadLocal/2.9 스레드 로컬 - 주의사항.md">2.9 스레드 로컬 - 주의사항</a>
1) 스레드 로컬 사용 후 저장 값 제거를 안 하면, 사용자 정보 유출 위험이 있다.
2) 스레드 로컬 사용 후 반드시 `remove`를 호출 하자.

---

## Chapter 03. 템플릿 메서드 패턴과 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.01 템플릿 메서드 패턴 - 시작.md">3.01 템플릿 메서드 패턴 - 시작</a>
1) 로그 추적기를 도입하니, 핵심기능에 부가기능이 잔뜩 붙어서 코드 복잡도가 많이 증가됐다.
2) 핵심 기능, 부가 기능
3) 동일한 패턴이 존재하는데 이를 공통화 할 방법이 없을까?
4) 변하는 것과 변하지 않는 것을 분리해야한다.
5) 해결책 : 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.02 템플릿 메서드 패턴 - 예제1.md">3.02 템플릿 메서드 패턴 - 예제1</a>
1) `templateMethodV0()` : 비즈니스 로직만 다르고 나머지는 모두 같은 두 코드
2) 변하는 부분, 변하지 않는 부분

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.03 템플릿 메서드 패턴 - 예제2.md">3.03 템플릿 메서드 패턴 - 예제2</a>
1) 템플릿 메서드 패턴(Template Method Pattern)
2) 추상 클래스를 통해 전체 틀을 정해두고, 변하는 부분을 하위 클래스에서 구현한다.
3) `templateMethodV1` : 템플릿 메서드 패턴 적용
4) 템플릿 메서드 패턴의 인스턴스 호출 과정

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.04 템플릿 메서드 패턴 - 예제3.md">3.04 템플릿 메서드 패턴 - 예제3</a>
1) 익명 내부 클래스 사용하기
2) `templateMethodV2()` - 템플릿 메서드 패턴에서 익명 내부 클래스를 사용

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.05 템플릿 메서드 패턴 - 적용1.md">3.05 템플릿 메서드 패턴 - 적용1</a>
1) `AbstractTemplate` : 로그 추적 템플릿
2) `v3` -> `v4` 복사
3) 애플리케이션 수정 : 템플릿 메서드 패턴 적용
4) 실행 확인

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.06 템플릿 메서드 패턴 - 적용2.md">3.06 템플릿 메서드 패턴 - 적용2</a>
1) 지금까지 작성한 코드 비교
2) 좋은 설계 : 변경에 쉽게 대처할 수 있는 코드
3) 템플릿 메서드 패턴과 단일 책임 원칙(SRP)

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.07 템플릿 메서드 패턴 - 정의.md">3.07 템플릿 메서드 패턴 - 정의</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.08 전략 패턴 - 시작.md">3.08 전략 패턴 - 시작</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.09 전략 패턴 - 예제1.md">3.09 전략 패턴 - 예제1</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.10 전략 패턴 - 예제2.md">3.10 전략 패턴 - 예제2</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.11 전략 패턴 - 예제3.md">3.11 전략 패턴 - 예제3</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.12 템플릿 콜백 패턴 - 시작.md">3.12 템플릿 콜백 패턴 - 시작</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.13 템플릿 콜백 패턴 - 예제.md">3.13 템플릿 콜백 패턴 - 예제</a>
작성 중

### <a href="Chapter 03. 템플릿 메서드 패턴과 콜백 패턴/3.14 템플릿 콜백 패턴 - 적용.md">3.14 템플릿 콜백 패턴 - 적용</a>
작성 중

---

## Chapter 04. 프록시 패턴과 데코레이터 패턴
### 4.01 프로젝트 생성
### 4.02 예제 프로젝트 만들기 v1
### 4.03 예제 프로젝트 만들기 v2
### 4.04 예제 프로젝트 만들기 v3
### 4.05 요구사항 추가
### 4.06 프록시, 프록시 패턴, 데코레이터 패턴 - 소개
### 4.07 프록시 패턴 - 예제 코드1
### 4.08 프록시 패턴 - 예제 코드2
### 4.09 데코레이터 패턴 - 예제 코드1
### 4.10 데코레이터 패턴 - 예제 코드2
### 4.11 데코레이터 패턴 - 예제 코드3
### 4.12 프록시 패턴과 데코레이터 패턴 정리
### 4.13 인터페이스 기반 프록시 - 적용
### 4.14 구체 클래스 기반 프록시 - 예제1
### 4.15 구체 클래스 기반 프록시 - 예제2
### 4.16 구체 클래스 기반 프록시 - 적용
### 4.17 인터페이스 기반 프록시와 클래스 기반 프록시

---

## Chapter 05. 동적 프록시 기술
### 5.1 리플렉션
### 5.2 JDK 동적 프록시 - 소개
### 5.3 JDK 동적 프록시 - 예제 코드
### 5.4 JDK 동적 프록시 - 적용1
### 5.5 JDK 동적 프록시 - 적용2
### 5.6 CGLIB - 소개
### 5.7 CGLIB - 예제 코드

---

## Chapter 06. 스프링이 지원하는 프록시
### 6.01 프록시 팩토리 - 소개
### 6.02 프록시 팩토리 - 예제 코드1
### 6.03 프록시 팩토리 - 예제 코드2
### 6.04 포인트컷, 어드바이스, 어드바이저 - 소개
### 6.05 예제 코드1 - 어드바이저
### 6.06 예제 코드2 - 직접 만든 포인트컷
### 6.07 예제 코드3 - 스프링이 제공하는 포인트컷
### 6.08 예제 코드4 - 여러 어드바이저 함께 적용
### 6.09 프록시 팩토리 - 적용1
### 6.10 프록시 팩토리 - 적용2

---

## Chapter 07. 빈 후처리기
### 7.1 빈 후처리기 - 소개
### 7.2 빈 후처리기 - 예제 코드1
### 7.3 빈 후처리기 - 예제 코드2
### 7.4 빈 후처리기 - 적용
### 7.5 빈 후처리기 - 정리
### 7.6 스프링이 제공하는 빈 후처리기1
### 7.7 스프링이 제공하는 빈 후처리기2
### 7.8 하나의 프록시, 여러 Advisor 적용

---

## Chapter 08. @Aspect AOP
### 8.1 @Aspect 프록시 - 적용
### 8.2 @Aspect 프록시 - 설명

---

## Chapter 09. 스프링 AOP 개념
### 9.1 AOP 소개 - 핵심 기능과 부가 기능
### 9.2 AOP 소개 - 애스펙트
### 9.3 AOP 적용 방식
### 9.4 AOP 용어 정리

---

## Chapter 10. 스프링 AOP 구현
### 10.1 프로젝트 생성
### 10.2 예제 프로젝트 만들기
### 10.3 스프링 AOP 구현1 - 시작
### 10.4 스프링 AOP 구현2 - 포인트컷 분리
### 10.5 스프링 AOP 구현3 - 어드바이스 추가
### 10.6 스프링 AOP 구현4 - 포인트컷 참조
### 10.7 스프링 AOP 구현5 - 어드바이스 순서
### 10.8 스프링 AOP 구현6 - 어드바이스 종류

---

## Chapter 11. 스프링 AOP - 포인트컷
### 11.01 포인트컷 지시자
### 11.02 예제 만들기
### 11.03 execution - 1
### 11.04 execution - 2
### 11.05 within
### 11.06 args
### 11.07 @target, @within
### 11.08 @annotation, @args
### 11.09 bean
### 11.10 매개변수 전달
### 11.11 this, target

---

## Chapter 12. 스프링 AOP - 실전 예제
### 12.1 예제 만들기
### 12.2 로그 출력 AOP
### 12.3 재시도 AOP

---

## Chapter 13. 스프링 AOP - 실무 주의사항
### 13.1 프록시와 내부 호출 - 문제
### 13.2 프록시와 내부 호출 - 대안1 자기 자신 주입
### 13.3 프록시와 내부 호출 - 대안2 지연 조회
### 13.4 프록시와 내부 호출 - 대안3 구조 변경
### 13.5 프록시 기술과 한계 - 타입 캐스팅
### 13.6 프록시 기술과 한계 - 의존관계 주입
### 13.7 프록시 기술과 한계 - CGLIB
### 13.8 프록시 기술과 한계 - 스프링의 해결책

---
